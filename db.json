{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/css/cursor.min.css","path":"css/cursor.min.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background.jpg","path":"images/background.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background.png","path":"images/background.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/home.jpg","path":"images/home.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/background.js","path":"js/lib/background.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/cursor.min.js","path":"js/lib/cursor.min.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/fireworks.js","path":"js/lib/fireworks.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"4fb9578e90d01815c566d424b5fc287536b406de","modified":1721954427810},{"_id":"source/categories/index.md","hash":"6b1bbf970b5f4e9cc88670e4fb3ecf283cdb57ff","modified":1721801190322},{"_id":"source/_posts/10-html2canvas绘制海报清晰.md","hash":"ab78930478ed42fd86ef37a00508562f825a73b8","modified":1721954926112},{"_id":"source/_posts/1-es6-let-const.md","hash":"6904a2661f44d4a923eeef113ce9e3d407f39774","modified":1721876002988},{"_id":"source/_posts/2-vue报错.md","hash":"3955c18cc2079de5d9864170153b4dcee8ae9f1c","modified":1721876463874},{"_id":"source/_posts/11-html2canvas生成图片底部出现白边儿的解决方法.md","hash":"c1f063ac640a1f81d84074e53e18832090b7c59a","modified":1721954922386},{"_id":"source/_posts/12-小程序文件预览.md","hash":"f7addab4420191b895947768f062daeb1ed77c0d","modified":1721954917909},{"_id":"source/_posts/3-Vue-set的正确使用.md","hash":"9179a0163ab45138808a8e54447eef1596895444","modified":1721878339192},{"_id":"source/_posts/4-vue为element-ui组件事件添加自定义参数.md","hash":"748645a135879ab5bee15e1d1998501b55b99b3f","modified":1721878529644},{"_id":"source/_posts/5-判断一个字符串格式是否为JSON字符串.md","hash":"eb14325a9403c1e32987097eec557f7d5513a43e","modified":1721878521440},{"_id":"source/_posts/6-微信小程序IOS时间格式不兼容问题.md","hash":"5d45c38a52726368458e161994d50b44d03a74bc","modified":1721878788057},{"_id":"source/_posts/7-小程序1rpx边框不完美解决方案.md","hash":"c0af409f0c9879ac09ac1603214ca5c3b19b19a4","modified":1721879017929},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）.md","hash":"4e65c1cbbfe56a5f25c16a177620774f7f55f069","modified":1721879405206},{"_id":"source/_posts/9-扩大按钮点击范围.md","hash":"0a7bdc2d48cd6db43b0aafc1dc6b56e3cfc76c0e","modified":1721879549509},{"_id":"source/tags/index.md","hash":"376e199366dae7fcd56352b3cb7ed74280a412a1","modified":1721800622594},{"_id":"source/_posts/3-Vue-set的正确使用/2.png","hash":"3b3c3529a39b8548a04e5e4c9c74a91f32244adc","modified":1721877354409},{"_id":"source/_posts/3-Vue-set的正确使用/1.png","hash":"c1bb7ab95fd7b0f2121d217621ee79e838d2c0e9","modified":1721877275121},{"_id":"source/_posts/3-Vue-set的正确使用/3.png","hash":"bfcd2be301f48fc106fb19ef929008128e576ddd","modified":1721877300205},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/2.png","hash":"a2ddbf0ed323c6289584bfaf7f32bbb6d6830b22","modified":1721879232902},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/3.png","hash":"fd6fbb9bc215a1a04b248caf091c91da1053c0ca","modified":1721879259404},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/1.png","hash":"7afa746f702580652adc32462a74354004318f72","modified":1721879199096},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1721716900457},{"_id":"themes/particlex/.gitignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1721716900455},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1721716900455},{"_id":"themes/particlex/README.md","hash":"19b124670bc5c9aa8cff0fc191be1e9a40c841a0","modified":1721716900457},{"_id":"themes/particlex/_config.yml","hash":"19fd445011982ce90674a765f023187586807952","modified":1721888955770},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"a29c2c1fca9c5dd49efe1452c9f44f56957967fa","modified":1721716900461},{"_id":"themes/particlex/package.json","hash":"cf27e24dcd81559d6d2537eba0582259f17817dd","modified":1721716900461},{"_id":"themes/particlex/layout/archives.ejs","hash":"c3878ffe435aa37ba46a0ee25c34257c2f2a1d87","modified":1721716900457},{"_id":"themes/particlex/layout/card.ejs","hash":"65e0c46a79c02212982c8a9aef1b16bfc3430429","modified":1721716900457},{"_id":"themes/particlex/.github/dependabot.yml","hash":"d2adc8df9ae7f28520d2fd5c0579e75dbe352bdc","modified":1721781677099},{"_id":"themes/particlex/layout/categories.ejs","hash":"73ff20a582c72e7cf138c7b42006447e4a2e110a","modified":1721716900457},{"_id":"themes/particlex/layout/current.ejs","hash":"4e75c06c9d0b1336c69c210567581e7efded5621","modified":1721716900457},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1721726939068},{"_id":"themes/particlex/layout/footer.ejs","hash":"357b2db2eab031150e06dd47695dc9916d875fc4","modified":1721716900457},{"_id":"themes/particlex/layout/import.ejs","hash":"7800720150b46a9abaf513316602a05293b3991b","modified":1721716900461},{"_id":"themes/particlex/layout/index.ejs","hash":"e7c208f1d9c0acb24f20180ffa45f48ee5ea5d71","modified":1721716900461},{"_id":"themes/particlex/layout/layout.ejs","hash":"3fbfd1c29218b8d114c3cb9f2cf69b2285573658","modified":1721868258003},{"_id":"themes/particlex/layout/tags.ejs","hash":"f5b821d45f2f44443adade62eb032f92215e0d62","modified":1721716900461},{"_id":"themes/particlex/layout/post.ejs","hash":"a3e567ac00d1ccd8a84525d20665318248da75a7","modified":1721716900461},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1721716900461},{"_id":"themes/particlex/layout/posts.ejs","hash":"c0d92ea2589d69522805daad16add5265a24a04d","modified":1721718561742},{"_id":"themes/particlex/source/css/main.css","hash":"ff49d90e3eb12de20b68a95c028a44d8d5f28a2e","modified":1721716900465},{"_id":"themes/particlex/source/images/avatar.jpg","hash":"6faa2a42a3c99fbfa775df57861ccaf879e95596","modified":1721718893910},{"_id":"themes/particlex/source/css/cursor.min.css","hash":"c5040cf6c867593f9629a10b27fe9777d1b4ed19","modified":1721868219399},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1721716900478},{"_id":"themes/particlex/source/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1721716900473},{"_id":"themes/particlex/source/js/lib/background.js","hash":"3d1201d64f26b680554e760f14267f0b076535d2","modified":1721868192293},{"_id":"themes/particlex/source/js/lib/cursor.min.js","hash":"de87e022db21f014841f93203a36e3db0942de2f","modified":1721868105905},{"_id":"themes/particlex/source/js/lib/fireworks.js","hash":"ad0f621562aad099ceff52e5943f951ce50e7ae7","modified":1721868203825},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"9631a74681b34ff1247837a338269f3c5efba45c","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1721716900478},{"_id":"themes/particlex/source/images/home.jpg","hash":"907204184bee1bd3ba40460c1a13457fa56b70ff","modified":1721888777697},{"_id":"themes/particlex/source/images/background.png","hash":"e9ac27f2c219f209061720fd986a9baf36b6ecb4","modified":1721719078562},{"_id":"themes/particlex/source/images/background.jpg","hash":"d4cd5b1193bcf15f9420ee92a321ab62b5b8c452","modified":1721716900473},{"_id":"public/about/index.html","hash":"3f3a49a8384823903e9338b87091d91eb8692058","modified":1721954936503},{"_id":"public/categories/index.html","hash":"7370470ba443ce3483b54162fc1d870a8547c071","modified":1721954936503},{"_id":"public/tags/index.html","hash":"5307cc62fb604dede43628b09856cc8ceffbafb9","modified":1721954936503},{"_id":"public/2024/07/26/12-小程序文件预览/index.html","hash":"2216877da23dbd23872f73ae00d34e25c3bd8a17","modified":1721954936503},{"_id":"public/2024/07/26/11-html2canvas生成图片底部出现白边儿的解决方法/index.html","hash":"5515ee5f99a0905a49222f163e48b8dab6d8f698","modified":1721954936503},{"_id":"public/2024/07/26/10-html2canvas绘制海报清晰/index.html","hash":"d964aec75428352b5445c702d0680ca6edd4209b","modified":1721954936503},{"_id":"public/2024/07/25/9-扩大按钮点击范围/index.html","hash":"2b2744170afd451ca22a7295e1b50080429804ef","modified":1721954936503},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/index.html","hash":"afb8e80c987db2412e7163e485dbe3ca3d9802cc","modified":1721954936503},{"_id":"public/2024/07/25/7-小程序1rpx边框不完美解决方案/index.html","hash":"fda11d931b731f32e544502671751a0db710fbea","modified":1721954936503},{"_id":"public/2024/07/25/6-微信小程序IOS时间格式不兼容问题/index.html","hash":"bcba8f41cae50cf1bd90924358c90837080d9c31","modified":1721954936503},{"_id":"public/2024/07/25/5-判断一个字符串格式是否为JSON字符串/index.html","hash":"9b270044255dcf4ee5e030c0a8708b9fac757e96","modified":1721954936503},{"_id":"public/2024/07/25/4-vue为element-ui组件事件添加自定义参数/index.html","hash":"2c9ae6acb7aaaed0d3b03596bfa1b4c8ff588f86","modified":1721954936503},{"_id":"public/2024/07/25/3-Vue-set的正确使用/index.html","hash":"84c7a949f96409c8e9d92eeda83f56b1a27d538d","modified":1721954936503},{"_id":"public/2024/07/25/2-vue报错/index.html","hash":"b97bd3d28df50e13229b2c236e208c8ef62d5baa","modified":1721954936503},{"_id":"public/2024/07/24/1-es6-let-const/index.html","hash":"8d7797fad07abc55b2e5ac41ac0d084d8ed47295","modified":1721954936503},{"_id":"public/tags/canvas/index.html","hash":"3742bd66ebc6440089133eec23d324322514b5e7","modified":1721954936503},{"_id":"public/tags/html2canvas/index.html","hash":"fc57a4fd76eb468e9cce0502242d7dbd2fc18413","modified":1721954936503},{"_id":"public/tags/es6/index.html","hash":"1f7153049643d3b3852141f409eb80e1cbafba1b","modified":1721954936503},{"_id":"public/tags/js/index.html","hash":"3830cf975fb68a46245541a694a250f012f6bc0a","modified":1721954936503},{"_id":"public/tags/小程序/index.html","hash":"bebc59111d76d3e6d7ae64fed2ef0f21e5bb75ab","modified":1721954936503},{"_id":"public/tags/vue/index.html","hash":"84f583a09f5c63eb51457edddb32289307ec2373","modified":1721954936503},{"_id":"public/tags/element-ui/index.html","hash":"6b1db6467ad1aa77c73833a8352f4871ed989da9","modified":1721954936503},{"_id":"public/tags/微信小程序/index.html","hash":"5e71a189a04e946d5c04430a386cb617259ebe1b","modified":1721954936503},{"_id":"public/tags/css/index.html","hash":"1a7a09c5569f9ed0301302e504760df63db9e5cd","modified":1721954936503},{"_id":"public/tags/IOS/index.html","hash":"985430e2991dc240a2b4f0d132490163d945f0d4","modified":1721954936503},{"_id":"public/tags/git/index.html","hash":"06ab421f806bbcef4f6f41f25ca771a12ca4bbff","modified":1721954936503},{"_id":"public/categories/工具/index.html","hash":"44766a4d71cb691a83744fcf23adc8d47326ab34","modified":1721954936503},{"_id":"public/page/2/index.html","hash":"cdb126b9e25e993b1621b990b04ba69692632c3b","modified":1721954936503},{"_id":"public/archives/index.html","hash":"8973b912902f30833de34777f5dc0a0f25299b4b","modified":1721954936503},{"_id":"public/archives/page/2/index.html","hash":"502030fbdd368b0513ee1655f3a1cd4bedac154d","modified":1721954936503},{"_id":"public/archives/2024/index.html","hash":"90b5bca72be12bcf0dd1e7c82173cb2b3f13f812","modified":1721954936503},{"_id":"public/archives/2024/page/2/index.html","hash":"4451b34fdaf9f1cd5a0ce24b39c4e5e62f591475","modified":1721954936503},{"_id":"public/archives/2024/07/index.html","hash":"e089145dac4c48538cbbb6bf85b9ab7b873a157d","modified":1721954936503},{"_id":"public/archives/2024/07/page/2/index.html","hash":"b139237956daff17808cd97072e6f4175b365ede","modified":1721954936503},{"_id":"public/categories/web前端/index.html","hash":"967765330cf6d0ece381f3c91f357fbee868b8e6","modified":1721954936503},{"_id":"public/categories/web前端/page/2/index.html","hash":"55a8d64f679e9ee1c0d5f9ace3ca929f4832200a","modified":1721954936503},{"_id":"public/index.html","hash":"5e3553773df7434602b97fb17f66c6b273a66321","modified":1721954936503},{"_id":"public/images/avatar.jpg","hash":"6faa2a42a3c99fbfa775df57861ccaf879e95596","modified":1721954936503},{"_id":"public/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1721954936503},{"_id":"public/2024/07/25/3-Vue-set的正确使用/1.png","hash":"c1bb7ab95fd7b0f2121d217621ee79e838d2c0e9","modified":1721954936503},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/2.png","hash":"a2ddbf0ed323c6289584bfaf7f32bbb6d6830b22","modified":1721954936503},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/3.png","hash":"fd6fbb9bc215a1a04b248caf091c91da1053c0ca","modified":1721954936503},{"_id":"public/2024/07/25/3-Vue-set的正确使用/2.png","hash":"3b3c3529a39b8548a04e5e4c9c74a91f32244adc","modified":1721954936503},{"_id":"public/2024/07/25/3-Vue-set的正确使用/3.png","hash":"bfcd2be301f48fc106fb19ef929008128e576ddd","modified":1721954936503},{"_id":"public/css/cursor.min.css","hash":"24aabac400205b91eac7ddf0e5df6a06114e7a67","modified":1721954936503},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1721954936503},{"_id":"public/js/lib/cursor.min.js","hash":"9b0cdeeb043f35cfc863a24852a9fcbcd6d997e7","modified":1721954936503},{"_id":"public/js/lib/fireworks.js","hash":"7b2691741d815b3ca017b302b498501aa8591589","modified":1721954936503},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1721954936503},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/1.png","hash":"7afa746f702580652adc32462a74354004318f72","modified":1721954936503},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1721954936503},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1721954936503},{"_id":"public/js/lib/highlight.js","hash":"c2b4c59c24728fc35dfa6339a1716d9897dcffe7","modified":1721954936503},{"_id":"public/js/lib/background.js","hash":"846e3547d0b7bb2aa888bcd0b45a9b78ed75c11f","modified":1721954936503},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1721954936503},{"_id":"public/css/main.css","hash":"444ff8856c320913dde037c43f24bba18ef4d741","modified":1721954936503},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1721954936503},{"_id":"public/images/home.jpg","hash":"907204184bee1bd3ba40460c1a13457fa56b70ff","modified":1721954936503},{"_id":"public/images/background.png","hash":"e9ac27f2c219f209061720fd986a9baf36b6ecb4","modified":1721954936503},{"_id":"public/images/background.jpg","hash":"d4cd5b1193bcf15f9420ee92a321ab62b5b8c452","modified":1721954936503}],"Category":[{"name":"web前端","_id":"clz1zid5k0004y4vcdpie9kpi"},{"name":"工具","_id":"clz1zid60001ny4vccmc32fvf"}],"Data":[],"Page":[{"title":"about","date":"2024-07-26T00:40:27.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-07-26 08:40:27\n---\n","updated":"2024-07-26T00:40:27.810Z","path":"about/index.html","comments":1,"layout":"page","_id":"clz1zid5f0000y4vc9tnu59qi","content":"","excerpt":"","more":""},{"title":"categories","date":"2024-07-24T05:53:36.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-07-24 13:53:36\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2024-07-24T06:06:30.322Z","path":"categories/index.html","comments":1,"_id":"clz1zid5j0002y4vc9nv3cogp","content":"","excerpt":"","more":""},{"title":"tags","date":"2024-07-24T05:55:03.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2024-07-24 13:55:03\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2024-07-24T05:57:02.594Z","path":"tags/index.html","comments":1,"_id":"clz1zid5m0006y4vc17gxcd33","content":"","excerpt":"","more":""}],"Post":[{"title":"html2canvas绘制海报清晰","date":"2024-07-26T00:42:32.000Z","description":"解决html2canvas绘制海报，生成海报比较模糊问题\n","_content":"\n\n#### 场景\n使用html2canvas绘制海报，生成海报比较模糊\n#### 解决方案\n##### 方案一：增大dpi\n\n>dpi:DPI是指某些设备分辨率的度量单位。DPI越低，扫描的清晰度越低，DPI越高，清晰度越高。\n由于受网络传输速度的影响，web上使用的图片都是72dpi，照片使用300dpi或者更高350dpi，会很清晰。\n\n##### 方案二：增大scale\n\n>scale会缩放canvas画布，提高/减小生成图片分辨率\n\n```\nscale: 3, // 按比例增加分辨率 (2=双倍).\n```\n\n##### 方案三：将页面图片引入方式由背景图改为img标签\n\n##### 方案四：分割转换\n>将目标元素分割为多个小块，并分别进行转换，最后将分割的图片交给后端把图片合成起来\n\n```\n    /**\n     * 绘制海报\n     * @param {*} picDom\n     * @param {*} picRef\n     */\n    createImgDebris(picDom, picRef) {\n      return new Promise(resolve => {\n        var targetDom = document.getElementById(picDom);\n        const setup = {\n          useCORS: true, // 使用跨域\n          height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n          width: targetDom.scrollWidth, //canvas宽\n          scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n          // scale: list.length > 25 ? 4.5 : 5.2, //按比例增加分辨率 (2=双倍).\n          // dpi: window.devicePixelRatio * 2 //设备像素比\n          dpi: window.devicePixelRatio * 2 //设备像素比\n        };\n        html2canvas(this.$refs[picRef], setup).then(canvas => {\n          let blockDataURL = canvas.toDataURL(\"image/jpg\");\n          resolve(blockDataURL);\n        });\n      });\n    },\n    \n    /**\n     * 海报生成图片\n     */\n    creatImg(type) {\n      let promiseList = [\n        this.createImgDebris(\"imgBoxBanner\", \"pictureBanner\"),\n        this.createImgDebris(\"imgBoxBox50\", \"pictureBox50\")\n      ];\n      Promise.all(promiseList).then(resList => {\n        this.uploadImg(resList, \"image/jpg\")\n      });\n    },\n```\n\n合并上传\n\n```\n    /**\n     * 合并上传图片\n     * @param {*} imgList\n     * @param {*} imgType\n     */\n    async uploadImg(imgList, imgType = \"image/jpg\") {\n      return new Promise((resolve, reject) => {\n        try {\n          // 创建 FormData 对象并添加图像数据\n          const formData = new FormData();\n          for (let len = imgList.length, i = 0; i < len; i++) {\n            let img = imgList[i];\n            const binaryImageData = atob(img.split(\",\")[1]);\n            // 创建一个缓冲数组来存储二进制数据\n            const buffer = new Uint8Array(binaryImageData.length);\n            // 将二进制数据复制到缓冲数组中\n            for (let i = 0; i < binaryImageData.length; i++) {\n              buffer[i] = binaryImageData.charCodeAt(i);\n            }\n            // 将缓冲数组转换为 Blob 对象\n            const blob = new Blob([buffer], { type: imgType });\n            formData.append(\"files\", blob, imgType);\n          }\n          mergeMaterialPost(formData).then(res => {\n            resolve(res);\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    },\n\n\n```\n","source":"_posts/10-html2canvas绘制海报清晰.md","raw":"---\ntitle: html2canvas绘制海报清晰\ndate: 2024-07-26 08:42:32\ntags:\n    [canvas, html2canvas]\ncategories: \n    - web前端\ndescription: |\n   解决html2canvas绘制海报，生成海报比较模糊问题\n---\n\n\n#### 场景\n使用html2canvas绘制海报，生成海报比较模糊\n#### 解决方案\n##### 方案一：增大dpi\n\n>dpi:DPI是指某些设备分辨率的度量单位。DPI越低，扫描的清晰度越低，DPI越高，清晰度越高。\n由于受网络传输速度的影响，web上使用的图片都是72dpi，照片使用300dpi或者更高350dpi，会很清晰。\n\n##### 方案二：增大scale\n\n>scale会缩放canvas画布，提高/减小生成图片分辨率\n\n```\nscale: 3, // 按比例增加分辨率 (2=双倍).\n```\n\n##### 方案三：将页面图片引入方式由背景图改为img标签\n\n##### 方案四：分割转换\n>将目标元素分割为多个小块，并分别进行转换，最后将分割的图片交给后端把图片合成起来\n\n```\n    /**\n     * 绘制海报\n     * @param {*} picDom\n     * @param {*} picRef\n     */\n    createImgDebris(picDom, picRef) {\n      return new Promise(resolve => {\n        var targetDom = document.getElementById(picDom);\n        const setup = {\n          useCORS: true, // 使用跨域\n          height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n          width: targetDom.scrollWidth, //canvas宽\n          scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n          // scale: list.length > 25 ? 4.5 : 5.2, //按比例增加分辨率 (2=双倍).\n          // dpi: window.devicePixelRatio * 2 //设备像素比\n          dpi: window.devicePixelRatio * 2 //设备像素比\n        };\n        html2canvas(this.$refs[picRef], setup).then(canvas => {\n          let blockDataURL = canvas.toDataURL(\"image/jpg\");\n          resolve(blockDataURL);\n        });\n      });\n    },\n    \n    /**\n     * 海报生成图片\n     */\n    creatImg(type) {\n      let promiseList = [\n        this.createImgDebris(\"imgBoxBanner\", \"pictureBanner\"),\n        this.createImgDebris(\"imgBoxBox50\", \"pictureBox50\")\n      ];\n      Promise.all(promiseList).then(resList => {\n        this.uploadImg(resList, \"image/jpg\")\n      });\n    },\n```\n\n合并上传\n\n```\n    /**\n     * 合并上传图片\n     * @param {*} imgList\n     * @param {*} imgType\n     */\n    async uploadImg(imgList, imgType = \"image/jpg\") {\n      return new Promise((resolve, reject) => {\n        try {\n          // 创建 FormData 对象并添加图像数据\n          const formData = new FormData();\n          for (let len = imgList.length, i = 0; i < len; i++) {\n            let img = imgList[i];\n            const binaryImageData = atob(img.split(\",\")[1]);\n            // 创建一个缓冲数组来存储二进制数据\n            const buffer = new Uint8Array(binaryImageData.length);\n            // 将二进制数据复制到缓冲数组中\n            for (let i = 0; i < binaryImageData.length; i++) {\n              buffer[i] = binaryImageData.charCodeAt(i);\n            }\n            // 将缓冲数组转换为 Blob 对象\n            const blob = new Blob([buffer], { type: imgType });\n            formData.append(\"files\", blob, imgType);\n          }\n          mergeMaterialPost(formData).then(res => {\n            resolve(res);\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    },\n\n\n```\n","slug":"10-html2canvas绘制海报清晰","published":1,"updated":"2024-07-26T00:48:46.112Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5h0001y4vc3z9zeo6i","content":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>使用html2canvas绘制海报，生成海报比较模糊</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><h5 id=\"方案一：增大dpi\"><a href=\"#方案一：增大dpi\" class=\"headerlink\" title=\"方案一：增大dpi\"></a>方案一：增大dpi</h5><blockquote>\n<p>dpi:DPI是指某些设备分辨率的度量单位。DPI越低，扫描的清晰度越低，DPI越高，清晰度越高。<br>由于受网络传输速度的影响，web上使用的图片都是72dpi，照片使用300dpi或者更高350dpi，会很清晰。</p>\n</blockquote>\n<h5 id=\"方案二：增大scale\"><a href=\"#方案二：增大scale\" class=\"headerlink\" title=\"方案二：增大scale\"></a>方案二：增大scale</h5><blockquote>\n<p>scale会缩放canvas画布，提高&#x2F;减小生成图片分辨率</p>\n</blockquote>\n<pre><code>scale: 3, // 按比例增加分辨率 (2=双倍).\n</code></pre>\n<h5 id=\"方案三：将页面图片引入方式由背景图改为img标签\"><a href=\"#方案三：将页面图片引入方式由背景图改为img标签\" class=\"headerlink\" title=\"方案三：将页面图片引入方式由背景图改为img标签\"></a>方案三：将页面图片引入方式由背景图改为img标签</h5><h5 id=\"方案四：分割转换\"><a href=\"#方案四：分割转换\" class=\"headerlink\" title=\"方案四：分割转换\"></a>方案四：分割转换</h5><blockquote>\n<p>将目标元素分割为多个小块，并分别进行转换，最后将分割的图片交给后端把图片合成起来</p>\n</blockquote>\n<pre><code>    /**\n     * 绘制海报\n     * @param &#123;*&#125; picDom\n     * @param &#123;*&#125; picRef\n     */\n    createImgDebris(picDom, picRef) &#123;\n      return new Promise(resolve =&gt; &#123;\n        var targetDom = document.getElementById(picDom);\n        const setup = &#123;\n          useCORS: true, // 使用跨域\n          height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n          width: targetDom.scrollWidth, //canvas宽\n          scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n          // scale: list.length &gt; 25 ? 4.5 : 5.2, //按比例增加分辨率 (2=双倍).\n          // dpi: window.devicePixelRatio * 2 //设备像素比\n          dpi: window.devicePixelRatio * 2 //设备像素比\n        &#125;;\n        html2canvas(this.$refs[picRef], setup).then(canvas =&gt; &#123;\n          let blockDataURL = canvas.toDataURL(&quot;image/jpg&quot;);\n          resolve(blockDataURL);\n        &#125;);\n      &#125;);\n    &#125;,\n    \n    /**\n     * 海报生成图片\n     */\n    creatImg(type) &#123;\n      let promiseList = [\n        this.createImgDebris(&quot;imgBoxBanner&quot;, &quot;pictureBanner&quot;),\n        this.createImgDebris(&quot;imgBoxBox50&quot;, &quot;pictureBox50&quot;)\n      ];\n      Promise.all(promiseList).then(resList =&gt; &#123;\n        this.uploadImg(resList, &quot;image/jpg&quot;)\n      &#125;);\n    &#125;,\n</code></pre>\n<p>合并上传</p>\n<pre><code>    /**\n     * 合并上传图片\n     * @param &#123;*&#125; imgList\n     * @param &#123;*&#125; imgType\n     */\n    async uploadImg(imgList, imgType = &quot;image/jpg&quot;) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n        try &#123;\n          // 创建 FormData 对象并添加图像数据\n          const formData = new FormData();\n          for (let len = imgList.length, i = 0; i &lt; len; i++) &#123;\n            let img = imgList[i];\n            const binaryImageData = atob(img.split(&quot;,&quot;)[1]);\n            // 创建一个缓冲数组来存储二进制数据\n            const buffer = new Uint8Array(binaryImageData.length);\n            // 将二进制数据复制到缓冲数组中\n            for (let i = 0; i &lt; binaryImageData.length; i++) &#123;\n              buffer[i] = binaryImageData.charCodeAt(i);\n            &#125;\n            // 将缓冲数组转换为 Blob 对象\n            const blob = new Blob([buffer], &#123; type: imgType &#125;);\n            formData.append(&quot;files&quot;, blob, imgType);\n          &#125;\n          mergeMaterialPost(formData).then(res =&gt; &#123;\n            resolve(res);\n          &#125;);\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n      &#125;);\n    &#125;,\n\n</code></pre>\n","excerpt":"","more":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>使用html2canvas绘制海报，生成海报比较模糊</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><h5 id=\"方案一：增大dpi\"><a href=\"#方案一：增大dpi\" class=\"headerlink\" title=\"方案一：增大dpi\"></a>方案一：增大dpi</h5><blockquote>\n<p>dpi:DPI是指某些设备分辨率的度量单位。DPI越低，扫描的清晰度越低，DPI越高，清晰度越高。<br>由于受网络传输速度的影响，web上使用的图片都是72dpi，照片使用300dpi或者更高350dpi，会很清晰。</p>\n</blockquote>\n<h5 id=\"方案二：增大scale\"><a href=\"#方案二：增大scale\" class=\"headerlink\" title=\"方案二：增大scale\"></a>方案二：增大scale</h5><blockquote>\n<p>scale会缩放canvas画布，提高&#x2F;减小生成图片分辨率</p>\n</blockquote>\n<pre><code>scale: 3, // 按比例增加分辨率 (2=双倍).\n</code></pre>\n<h5 id=\"方案三：将页面图片引入方式由背景图改为img标签\"><a href=\"#方案三：将页面图片引入方式由背景图改为img标签\" class=\"headerlink\" title=\"方案三：将页面图片引入方式由背景图改为img标签\"></a>方案三：将页面图片引入方式由背景图改为img标签</h5><h5 id=\"方案四：分割转换\"><a href=\"#方案四：分割转换\" class=\"headerlink\" title=\"方案四：分割转换\"></a>方案四：分割转换</h5><blockquote>\n<p>将目标元素分割为多个小块，并分别进行转换，最后将分割的图片交给后端把图片合成起来</p>\n</blockquote>\n<pre><code>    /**\n     * 绘制海报\n     * @param &#123;*&#125; picDom\n     * @param &#123;*&#125; picRef\n     */\n    createImgDebris(picDom, picRef) &#123;\n      return new Promise(resolve =&gt; &#123;\n        var targetDom = document.getElementById(picDom);\n        const setup = &#123;\n          useCORS: true, // 使用跨域\n          height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n          width: targetDom.scrollWidth, //canvas宽\n          scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n          // scale: list.length &gt; 25 ? 4.5 : 5.2, //按比例增加分辨率 (2=双倍).\n          // dpi: window.devicePixelRatio * 2 //设备像素比\n          dpi: window.devicePixelRatio * 2 //设备像素比\n        &#125;;\n        html2canvas(this.$refs[picRef], setup).then(canvas =&gt; &#123;\n          let blockDataURL = canvas.toDataURL(&quot;image/jpg&quot;);\n          resolve(blockDataURL);\n        &#125;);\n      &#125;);\n    &#125;,\n    \n    /**\n     * 海报生成图片\n     */\n    creatImg(type) &#123;\n      let promiseList = [\n        this.createImgDebris(&quot;imgBoxBanner&quot;, &quot;pictureBanner&quot;),\n        this.createImgDebris(&quot;imgBoxBox50&quot;, &quot;pictureBox50&quot;)\n      ];\n      Promise.all(promiseList).then(resList =&gt; &#123;\n        this.uploadImg(resList, &quot;image/jpg&quot;)\n      &#125;);\n    &#125;,\n</code></pre>\n<p>合并上传</p>\n<pre><code>    /**\n     * 合并上传图片\n     * @param &#123;*&#125; imgList\n     * @param &#123;*&#125; imgType\n     */\n    async uploadImg(imgList, imgType = &quot;image/jpg&quot;) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n        try &#123;\n          // 创建 FormData 对象并添加图像数据\n          const formData = new FormData();\n          for (let len = imgList.length, i = 0; i &lt; len; i++) &#123;\n            let img = imgList[i];\n            const binaryImageData = atob(img.split(&quot;,&quot;)[1]);\n            // 创建一个缓冲数组来存储二进制数据\n            const buffer = new Uint8Array(binaryImageData.length);\n            // 将二进制数据复制到缓冲数组中\n            for (let i = 0; i &lt; binaryImageData.length; i++) &#123;\n              buffer[i] = binaryImageData.charCodeAt(i);\n            &#125;\n            // 将缓冲数组转换为 Blob 对象\n            const blob = new Blob([buffer], &#123; type: imgType &#125;);\n            formData.append(&quot;files&quot;, blob, imgType);\n          &#125;\n          mergeMaterialPost(formData).then(res =&gt; &#123;\n            resolve(res);\n          &#125;);\n        &#125; catch (error) &#123;\n          reject(error);\n        &#125;\n      &#125;);\n    &#125;,\n\n</code></pre>\n"},{"title":"es6之let，const的使用","date":"2024-07-24T12:34:18.000Z","description":"es6之let，const新特性\n","_content":"\n# let，const的一些特点\n\n 1. 使用let或者const定义会形成块级作用域，一个{}就是一个作用域\n 2. let，const没有与解析\n 3. 同一个作用域下不能同时定义同一个变量\n 4. for循环时使用let来定义变量\n\n \t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      console.log(i) // 0 1 2 3 4 \n    }\n    alert(i) // 报错，i is not defined\n\t```\n\t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      let i = 'i 是否已经被定义了？'\n      console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = 'i 是否已经被定义了？'并没有在同一个作用域下\n    }\n\t```\n\t从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域\n5. 暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的\n\t```javascript\n\t// 暂时性死区\n    a = 30; // 暂时性死区开始(ReferenceError)\n    alert(a)  // ReferenceError\n    alert(b) // ReferenceError\n    let a = 10; // 暂时性死区结束\n    let b = 20;\n\t```\n6. const定义的变量不能再次重新被赋值\n7. 使用const定义变量的时候必须赋值\n\t```javascript\n\tconst a ;\n    console.log(a)  //  SyntaxError: Missing initializer in const declaration\n\t```","source":"_posts/1-es6-let-const.md","raw":"---\ntitle: es6之let，const的使用\ndate: 2024-07-24 20:34:18\ntags:\n    [es6, js]\ncategories: \n    - web前端\ndescription: |\n    es6之let，const新特性\n---\n\n# let，const的一些特点\n\n 1. 使用let或者const定义会形成块级作用域，一个{}就是一个作用域\n 2. let，const没有与解析\n 3. 同一个作用域下不能同时定义同一个变量\n 4. for循环时使用let来定义变量\n\n \t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      console.log(i) // 0 1 2 3 4 \n    }\n    alert(i) // 报错，i is not defined\n\t```\n\t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      let i = 'i 是否已经被定义了？'\n      console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = 'i 是否已经被定义了？'并没有在同一个作用域下\n    }\n\t```\n\t从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域\n5. 暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的\n\t```javascript\n\t// 暂时性死区\n    a = 30; // 暂时性死区开始(ReferenceError)\n    alert(a)  // ReferenceError\n    alert(b) // ReferenceError\n    let a = 10; // 暂时性死区结束\n    let b = 20;\n\t```\n6. const定义的变量不能再次重新被赋值\n7. 使用const定义变量的时候必须赋值\n\t```javascript\n\tconst a ;\n    console.log(a)  //  SyntaxError: Missing initializer in const declaration\n\t```","slug":"1-es6-let-const","published":1,"updated":"2024-07-25T02:53:22.988Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5j0003y4vccsaxbbx2","content":"<h1 id=\"let，const的一些特点\"><a href=\"#let，const的一些特点\" class=\"headerlink\" title=\"let，const的一些特点\"></a>let，const的一些特点</h1><ol>\n<li><p>使用let或者const定义会形成块级作用域，一个{}就是一个作用域</p>\n</li>\n<li><p>let，const没有与解析</p>\n</li>\n<li><p>同一个作用域下不能同时定义同一个变量</p>\n</li>\n<li><p>for循环时使用let来定义变量</p>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n console.log(i) // 0 1 2 3 4 \n&#125;\nalert(i) // 报错，i is not defined\n</code></pre>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n  let i = &#39;i 是否已经被定义了？&#39;\n  console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = &#39;i 是否已经被定义了？&#39;并没有在同一个作用域下\n&#125;\n</code></pre>\n<p>从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域</p>\n</li>\n<li><p>暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的</p>\n<pre><code class=\"javascript\">// 暂时性死区\na = 30; // 暂时性死区开始(ReferenceError)\nalert(a)  // ReferenceError\nalert(b) // ReferenceError\nlet a = 10; // 暂时性死区结束\nlet b = 20;\n</code></pre>\n</li>\n<li><p>const定义的变量不能再次重新被赋值</p>\n</li>\n<li><p>使用const定义变量的时候必须赋值</p>\n<pre><code class=\"javascript\">const a ;\nconsole.log(a)  //  SyntaxError: Missing initializer in const declaration\n</code></pre>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"let，const的一些特点\"><a href=\"#let，const的一些特点\" class=\"headerlink\" title=\"let，const的一些特点\"></a>let，const的一些特点</h1><ol>\n<li><p>使用let或者const定义会形成块级作用域，一个{}就是一个作用域</p>\n</li>\n<li><p>let，const没有与解析</p>\n</li>\n<li><p>同一个作用域下不能同时定义同一个变量</p>\n</li>\n<li><p>for循环时使用let来定义变量</p>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n console.log(i) // 0 1 2 3 4 \n&#125;\nalert(i) // 报错，i is not defined\n</code></pre>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n  let i = &#39;i 是否已经被定义了？&#39;\n  console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = &#39;i 是否已经被定义了？&#39;并没有在同一个作用域下\n&#125;\n</code></pre>\n<p>从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域</p>\n</li>\n<li><p>暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的</p>\n<pre><code class=\"javascript\">// 暂时性死区\na = 30; // 暂时性死区开始(ReferenceError)\nalert(a)  // ReferenceError\nalert(b) // ReferenceError\nlet a = 10; // 暂时性死区结束\nlet b = 20;\n</code></pre>\n</li>\n<li><p>const定义的变量不能再次重新被赋值</p>\n</li>\n<li><p>使用const定义变量的时候必须赋值</p>\n<pre><code class=\"javascript\">const a ;\nconsole.log(a)  //  SyntaxError: Missing initializer in const declaration\n</code></pre>\n</li>\n</ol>\n"},{"title":"html2canvas生成图片底部出现白边儿的解决方法","date":"2024-07-26T00:44:24.000Z","description":"#### 场景\n使用html2canvas的时候，生成的图片底部出现了白边\n\n#### 产生白边原因\n\n可能是由于像素渲染问题导致的。移动设备的屏幕像素密度（Pixel Density）较高，有时会导致在两个相邻元素之间出现细小的间隙或白线。\n","_content":"#### 场景\n使用html2canvas的时候，生成的图片底部出现了白边\n\n#### 产生白边原因\n\n可能是由于像素渲染问题导致的。移动设备的屏幕像素密度（Pixel Density）较高，有时会导致在两个相邻元素之间出现细小的间隙或白线。\n\n#### 解决方法\n将canvas画布高度调小1像素\n```\nvar targetDom = document.getElementById(picDom);\nconst setup = {\n    useCORS: true, // 使用跨域\n    height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n    width: targetDom.scrollWidth, //canvas宽\n    scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n    dpi: window.devicePixelRatio * 2 //设备像素比\n };\nhtml2canvas(this.$refs[picRef], setup).then(canvas => {\n    let blockDataURL = canvas.toDataURL(\"image/jpg\");\n});\n```","source":"_posts/11-html2canvas生成图片底部出现白边儿的解决方法.md","raw":"---\ntitle: html2canvas生成图片底部出现白边儿的解决方法\ndate: 2024-07-26 08:44:24\ntags:\n    [canvas, html2canvas]\ncategories: \n    - web前端\ndescription: |\n    #### 场景\n    使用html2canvas的时候，生成的图片底部出现了白边\n\n    #### 产生白边原因\n\n    可能是由于像素渲染问题导致的。移动设备的屏幕像素密度（Pixel Density）较高，有时会导致在两个相邻元素之间出现细小的间隙或白线。\n---\n#### 场景\n使用html2canvas的时候，生成的图片底部出现了白边\n\n#### 产生白边原因\n\n可能是由于像素渲染问题导致的。移动设备的屏幕像素密度（Pixel Density）较高，有时会导致在两个相邻元素之间出现细小的间隙或白线。\n\n#### 解决方法\n将canvas画布高度调小1像素\n```\nvar targetDom = document.getElementById(picDom);\nconst setup = {\n    useCORS: true, // 使用跨域\n    height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n    width: targetDom.scrollWidth, //canvas宽\n    scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n    dpi: window.devicePixelRatio * 2 //设备像素比\n };\nhtml2canvas(this.$refs[picRef], setup).then(canvas => {\n    let blockDataURL = canvas.toDataURL(\"image/jpg\");\n});\n```","slug":"11-html2canvas生成图片底部出现白边儿的解决方法","published":1,"updated":"2024-07-26T00:48:42.386Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5m0007y4vcew5u8s06","content":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>使用html2canvas的时候，生成的图片底部出现了白边</p>\n<h4 id=\"产生白边原因\"><a href=\"#产生白边原因\" class=\"headerlink\" title=\"产生白边原因\"></a>产生白边原因</h4><p>可能是由于像素渲染问题导致的。移动设备的屏幕像素密度（Pixel Density）较高，有时会导致在两个相邻元素之间出现细小的间隙或白线。</p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>将canvas画布高度调小1像素</p>\n<pre><code>var targetDom = document.getElementById(picDom);\nconst setup = &#123;\n    useCORS: true, // 使用跨域\n    height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n    width: targetDom.scrollWidth, //canvas宽\n    scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n    dpi: window.devicePixelRatio * 2 //设备像素比\n &#125;;\nhtml2canvas(this.$refs[picRef], setup).then(canvas =&gt; &#123;\n    let blockDataURL = canvas.toDataURL(&quot;image/jpg&quot;);\n&#125;);\n</code></pre>\n","excerpt":"","more":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>使用html2canvas的时候，生成的图片底部出现了白边</p>\n<h4 id=\"产生白边原因\"><a href=\"#产生白边原因\" class=\"headerlink\" title=\"产生白边原因\"></a>产生白边原因</h4><p>可能是由于像素渲染问题导致的。移动设备的屏幕像素密度（Pixel Density）较高，有时会导致在两个相邻元素之间出现细小的间隙或白线。</p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>将canvas画布高度调小1像素</p>\n<pre><code>var targetDom = document.getElementById(picDom);\nconst setup = &#123;\n    useCORS: true, // 使用跨域\n    height: targetDom.scrollHeight - 1, //canvas高, 高度减 1 是为了解决底部出现白线问题\n    width: targetDom.scrollWidth, //canvas宽\n    scale: this.isPad ? 6 : 7.5, //按比例增加分辨率 (2=双倍).\n    dpi: window.devicePixelRatio * 2 //设备像素比\n &#125;;\nhtml2canvas(this.$refs[picRef], setup).then(canvas =&gt; &#123;\n    let blockDataURL = canvas.toDataURL(&quot;image/jpg&quot;);\n&#125;);\n</code></pre>\n"},{"title":"小程序 - 文件预览","date":"2024-07-26T00:46:06.000Z","description":">注意事项\n1. wx.openDocument方法 ios 不支持打开txt文本，需单单独处理\n2. wx.downloadFile ios下载空文件 报错：downloadFile:fail file data is empty， 需根据fail报错信息单独处理\n","_content":"\n#### 小程序文件预览\n\n```\n/** 预览 - txt文本 */\n  viewTxt(path) {\n    let fs = wx.getFileSystemManager();\n    let _this = this;\n    fs.readFile({\n      filePath: path,\n      encoding: \"utf8\",\n      position: 0,\n      success(res) {\n        _this.setData({\n          setNoRefresh: true\n        });\n        wx.navigateTo({\n          url: `/pages/view-txt/view-txt?content=${res.data}`\n        });\n      },\n      fail(res) {\n        showToast(\"文件打开失败\");\n        console.error(res);\n      }\n    });\n  },\n  \n  /** 预览 - 文件 */\n  viewFile(path, type) {\n    wx.openDocument({\n      filePath: path,\n      // 文档类型\n      fileType: type,\n      success(res) {\n        console.log(\"打开文档成功\", res);\n      },\n      complete(err) {\n        console.log(\"打开文档成功2\", err);\n      },\n      fail() {\n        showToast(\"文件打开失败\");\n      }\n    });\n  },\n  \n  /** 在线预览文档 */\n  openDocument(e) {\n    let { item } = e.detail;\n    let _this = this;\n    wx.downloadFile({\n      url: item.materialUrl,\n      success(res) {\n        const path = res.tempFilePath;\n        if (item.materialUrl.endsWith(\".txt\")) {\n          _this.viewTxt(path);\n        } else {\n          _this.viewFile(path, item.type);\n        }\n      },\n      fail(err) {\n        if (err.errMsg.includes(\"downloadFile:fail file data is empty\")) {\n          wx.navigateTo({\n            url: `/pages/view-txt/view-txt?content=`\n          });\n        } else {\n          showToast(\"文件打开失败\");\n        }\n      }\n    });\n  },\n```\n\n>注意事项\n1. wx.openDocument方法 ios 不支持打开txt文本，需单单独处理\n2. wx.downloadFile ios下载空文件 报错：downloadFile:fail file data is empty， 需根据fail报错信息单独处理\n\n\n","source":"_posts/12-小程序文件预览.md","raw":"---\ntitle: 小程序 - 文件预览\ndate: 2024-07-26 08:46:06\ntags:\n    [小程序]\ncategories: \n    - web前端\ndescription: |\n    >注意事项\n    1. wx.openDocument方法 ios 不支持打开txt文本，需单单独处理\n    2. wx.downloadFile ios下载空文件 报错：downloadFile:fail file data is empty， 需根据fail报错信息单独处理\n---\n\n#### 小程序文件预览\n\n```\n/** 预览 - txt文本 */\n  viewTxt(path) {\n    let fs = wx.getFileSystemManager();\n    let _this = this;\n    fs.readFile({\n      filePath: path,\n      encoding: \"utf8\",\n      position: 0,\n      success(res) {\n        _this.setData({\n          setNoRefresh: true\n        });\n        wx.navigateTo({\n          url: `/pages/view-txt/view-txt?content=${res.data}`\n        });\n      },\n      fail(res) {\n        showToast(\"文件打开失败\");\n        console.error(res);\n      }\n    });\n  },\n  \n  /** 预览 - 文件 */\n  viewFile(path, type) {\n    wx.openDocument({\n      filePath: path,\n      // 文档类型\n      fileType: type,\n      success(res) {\n        console.log(\"打开文档成功\", res);\n      },\n      complete(err) {\n        console.log(\"打开文档成功2\", err);\n      },\n      fail() {\n        showToast(\"文件打开失败\");\n      }\n    });\n  },\n  \n  /** 在线预览文档 */\n  openDocument(e) {\n    let { item } = e.detail;\n    let _this = this;\n    wx.downloadFile({\n      url: item.materialUrl,\n      success(res) {\n        const path = res.tempFilePath;\n        if (item.materialUrl.endsWith(\".txt\")) {\n          _this.viewTxt(path);\n        } else {\n          _this.viewFile(path, item.type);\n        }\n      },\n      fail(err) {\n        if (err.errMsg.includes(\"downloadFile:fail file data is empty\")) {\n          wx.navigateTo({\n            url: `/pages/view-txt/view-txt?content=`\n          });\n        } else {\n          showToast(\"文件打开失败\");\n        }\n      }\n    });\n  },\n```\n\n>注意事项\n1. wx.openDocument方法 ios 不支持打开txt文本，需单单独处理\n2. wx.downloadFile ios下载空文件 报错：downloadFile:fail file data is empty， 需根据fail报错信息单独处理\n\n\n","slug":"12-小程序文件预览","published":1,"updated":"2024-07-26T00:48:37.909Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5n0008y4vcddwr54vf","content":"<h4 id=\"小程序文件预览\"><a href=\"#小程序文件预览\" class=\"headerlink\" title=\"小程序文件预览\"></a>小程序文件预览</h4><pre><code>/** 预览 - txt文本 */\n  viewTxt(path) &#123;\n    let fs = wx.getFileSystemManager();\n    let _this = this;\n    fs.readFile(&#123;\n      filePath: path,\n      encoding: &quot;utf8&quot;,\n      position: 0,\n      success(res) &#123;\n        _this.setData(&#123;\n          setNoRefresh: true\n        &#125;);\n        wx.navigateTo(&#123;\n          url: `/pages/view-txt/view-txt?content=$&#123;res.data&#125;`\n        &#125;);\n      &#125;,\n      fail(res) &#123;\n        showToast(&quot;文件打开失败&quot;);\n        console.error(res);\n      &#125;\n    &#125;);\n  &#125;,\n  \n  /** 预览 - 文件 */\n  viewFile(path, type) &#123;\n    wx.openDocument(&#123;\n      filePath: path,\n      // 文档类型\n      fileType: type,\n      success(res) &#123;\n        console.log(&quot;打开文档成功&quot;, res);\n      &#125;,\n      complete(err) &#123;\n        console.log(&quot;打开文档成功2&quot;, err);\n      &#125;,\n      fail() &#123;\n        showToast(&quot;文件打开失败&quot;);\n      &#125;\n    &#125;);\n  &#125;,\n  \n  /** 在线预览文档 */\n  openDocument(e) &#123;\n    let &#123; item &#125; = e.detail;\n    let _this = this;\n    wx.downloadFile(&#123;\n      url: item.materialUrl,\n      success(res) &#123;\n        const path = res.tempFilePath;\n        if (item.materialUrl.endsWith(&quot;.txt&quot;)) &#123;\n          _this.viewTxt(path);\n        &#125; else &#123;\n          _this.viewFile(path, item.type);\n        &#125;\n      &#125;,\n      fail(err) &#123;\n        if (err.errMsg.includes(&quot;downloadFile:fail file data is empty&quot;)) &#123;\n          wx.navigateTo(&#123;\n            url: `/pages/view-txt/view-txt?content=`\n          &#125;);\n        &#125; else &#123;\n          showToast(&quot;文件打开失败&quot;);\n        &#125;\n      &#125;\n    &#125;);\n  &#125;,\n</code></pre>\n<blockquote>\n<p>注意事项</p>\n</blockquote>\n<ol>\n<li>wx.openDocument方法 ios 不支持打开txt文本，需单单独处理</li>\n<li>wx.downloadFile ios下载空文件 报错：downloadFile:fail file data is empty， 需根据fail报错信息单独处理</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"小程序文件预览\"><a href=\"#小程序文件预览\" class=\"headerlink\" title=\"小程序文件预览\"></a>小程序文件预览</h4><pre><code>/** 预览 - txt文本 */\n  viewTxt(path) &#123;\n    let fs = wx.getFileSystemManager();\n    let _this = this;\n    fs.readFile(&#123;\n      filePath: path,\n      encoding: &quot;utf8&quot;,\n      position: 0,\n      success(res) &#123;\n        _this.setData(&#123;\n          setNoRefresh: true\n        &#125;);\n        wx.navigateTo(&#123;\n          url: `/pages/view-txt/view-txt?content=$&#123;res.data&#125;`\n        &#125;);\n      &#125;,\n      fail(res) &#123;\n        showToast(&quot;文件打开失败&quot;);\n        console.error(res);\n      &#125;\n    &#125;);\n  &#125;,\n  \n  /** 预览 - 文件 */\n  viewFile(path, type) &#123;\n    wx.openDocument(&#123;\n      filePath: path,\n      // 文档类型\n      fileType: type,\n      success(res) &#123;\n        console.log(&quot;打开文档成功&quot;, res);\n      &#125;,\n      complete(err) &#123;\n        console.log(&quot;打开文档成功2&quot;, err);\n      &#125;,\n      fail() &#123;\n        showToast(&quot;文件打开失败&quot;);\n      &#125;\n    &#125;);\n  &#125;,\n  \n  /** 在线预览文档 */\n  openDocument(e) &#123;\n    let &#123; item &#125; = e.detail;\n    let _this = this;\n    wx.downloadFile(&#123;\n      url: item.materialUrl,\n      success(res) &#123;\n        const path = res.tempFilePath;\n        if (item.materialUrl.endsWith(&quot;.txt&quot;)) &#123;\n          _this.viewTxt(path);\n        &#125; else &#123;\n          _this.viewFile(path, item.type);\n        &#125;\n      &#125;,\n      fail(err) &#123;\n        if (err.errMsg.includes(&quot;downloadFile:fail file data is empty&quot;)) &#123;\n          wx.navigateTo(&#123;\n            url: `/pages/view-txt/view-txt?content=`\n          &#125;);\n        &#125; else &#123;\n          showToast(&quot;文件打开失败&quot;);\n        &#125;\n      &#125;\n    &#125;);\n  &#125;,\n</code></pre>\n<blockquote>\n<p>注意事项</p>\n</blockquote>\n<ol>\n<li>wx.openDocument方法 ios 不支持打开txt文本，需单单独处理</li>\n<li>wx.downloadFile ios下载空文件 报错：downloadFile:fail file data is empty， 需根据fail报错信息单独处理</li>\n</ol>\n"},{"title":"如何为element-ui组件定义的事件添加自己的参数","date":"2024-07-25T03:31:51.000Z","description":"我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n","_content":"\n我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n\n废话不多说，直接看代码：\n这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去\n````\n<template>\n\t<div class=\"hello\">\n\t\t<div v-for=\"(item, index) in items\" :key=\"index\">\n\t\t\t<el-radio @change=\"(data) => {getdata(item.name, data)}\" v-model=\"radio\" label=\"1\">{{ item.name }}</el-radio>\n\t\t\t<el-radio v-model=\"radio\" label=\"2\">{{ item.name }}</el-radio>\n\t\t</div>\n\t</div>\n</template>\n````\n````\n<script>\nexport default {\n  data() {\n    return {\n      radio: \"1\",\n      items: [{name: 'lis'}, {name: '13'}]\n    };\n  },\n  methods: {\n    getdata(index, data) {\n      console.log(data, index);\n    }\n  },\n  mounted() {}\n};\n</script>\n````\n\n原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数\n\n\n补充：可以使用$event 来获取到事件对象e","source":"_posts/4-vue为element-ui组件事件添加自定义参数.md","raw":"---\ntitle: 如何为element-ui组件定义的事件添加自己的参数\ndate: 2024-07-25 11:31:51\ntags:\n    [vue, element-ui]\ncategories: \n    - web前端\ndescription: |\n    我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n---\n\n我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n\n废话不多说，直接看代码：\n这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去\n````\n<template>\n\t<div class=\"hello\">\n\t\t<div v-for=\"(item, index) in items\" :key=\"index\">\n\t\t\t<el-radio @change=\"(data) => {getdata(item.name, data)}\" v-model=\"radio\" label=\"1\">{{ item.name }}</el-radio>\n\t\t\t<el-radio v-model=\"radio\" label=\"2\">{{ item.name }}</el-radio>\n\t\t</div>\n\t</div>\n</template>\n````\n````\n<script>\nexport default {\n  data() {\n    return {\n      radio: \"1\",\n      items: [{name: 'lis'}, {name: '13'}]\n    };\n  },\n  methods: {\n    getdata(index, data) {\n      console.log(data, index);\n    }\n  },\n  mounted() {}\n};\n</script>\n````\n\n原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数\n\n\n补充：可以使用$event 来获取到事件对象e","slug":"4-vue为element-ui组件事件添加自定义参数","published":1,"updated":"2024-07-25T03:35:29.644Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5n0009y4vc31p3hg5b","content":"<p>我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？</p>\n<p>废话不多说，直接看代码：<br>这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去</p>\n<pre><code>&lt;template&gt;\n    &lt;div class=&quot;hello&quot;&gt;\n        &lt;div v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;\n            &lt;el-radio @change=&quot;(data) =&gt; &#123;getdata(item.name, data)&#125;&quot; v-model=&quot;radio&quot; label=&quot;1&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n            &lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code>&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      radio: &quot;1&quot;,\n      items: [&#123;name: &#39;lis&#39;&#125;, &#123;name: &#39;13&#39;&#125;]\n    &#125;;\n  &#125;,\n  methods: &#123;\n    getdata(index, data) &#123;\n      console.log(data, index);\n    &#125;\n  &#125;,\n  mounted() &#123;&#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数</p>\n<p>补充：可以使用$event 来获取到事件对象e</p>\n","excerpt":"","more":"<p>我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？</p>\n<p>废话不多说，直接看代码：<br>这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去</p>\n<pre><code>&lt;template&gt;\n    &lt;div class=&quot;hello&quot;&gt;\n        &lt;div v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;\n            &lt;el-radio @change=&quot;(data) =&gt; &#123;getdata(item.name, data)&#125;&quot; v-model=&quot;radio&quot; label=&quot;1&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n            &lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code>&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      radio: &quot;1&quot;,\n      items: [&#123;name: &#39;lis&#39;&#125;, &#123;name: &#39;13&#39;&#125;]\n    &#125;;\n  &#125;,\n  methods: &#123;\n    getdata(index, data) &#123;\n      console.log(data, index);\n    &#125;\n  &#125;,\n  mounted() &#123;&#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数</p>\n<p>补充：可以使用$event 来获取到事件对象e</p>\n"},{"title":"this.$set的正确使用","date":"2024-07-25T02:59:15.000Z","description":"this.$set的正确使用\n","_content":"## this.#set(obj, key, value)\n我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性\n````javascript\n<template>\n  <div class=\"hello\">\n    <button @click=\"setMessage\">添加属性</button>\n    {{ student.name }}\n    <input type=\"text\" v-model=\"student.age\">\n  </div>\n</template>\n````\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新\n \n![在这里插入图片描述](./1.png)\n![在这里插入图片描述](./2.png)\n在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化\n\n那么，我们该如何解决这个问题呢\n解决这个问题的方法大体有两种：\n\n 1. 使用this.$set(obj, key, value)/vue.set(obj, key, value)\n\n ````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.$set(this.student, 'age', 15)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n  ````\n2. 通过Object.assign(target, sources)方法\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      this.student = Object.assign({}, this.student)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦\n![在这里插入图片描述](./3.png)","source":"_posts/3-Vue-set的正确使用.md","raw":"---\ntitle: this.$set的正确使用\ndate: 2024-07-25 10:59:15\ntags:\n    [vue]\ncategories: \n    - web前端\ndescription: |\n    this.$set的正确使用\n---\n## this.#set(obj, key, value)\n我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性\n````javascript\n<template>\n  <div class=\"hello\">\n    <button @click=\"setMessage\">添加属性</button>\n    {{ student.name }}\n    <input type=\"text\" v-model=\"student.age\">\n  </div>\n</template>\n````\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新\n \n![在这里插入图片描述](./1.png)\n![在这里插入图片描述](./2.png)\n在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化\n\n那么，我们该如何解决这个问题呢\n解决这个问题的方法大体有两种：\n\n 1. 使用this.$set(obj, key, value)/vue.set(obj, key, value)\n\n ````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.$set(this.student, 'age', 15)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n  ````\n2. 通过Object.assign(target, sources)方法\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      this.student = Object.assign({}, this.student)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦\n![在这里插入图片描述](./3.png)","slug":"3-Vue-set的正确使用","published":1,"updated":"2024-07-25T03:32:19.192Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5p000cy4vc7jwj7pkz","content":"<h2 id=\"this-set-obj-key-value\"><a href=\"#this-set-obj-key-value\" class=\"headerlink\" title=\"this.#set(obj, key, value)\"></a>this.#set(obj, key, value)</h2><p>我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性</p>\n<pre><code class=\"javascript\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;button @click=&quot;setMessage&quot;&gt;添加属性&lt;/button&gt;\n    &#123;&#123; student.name &#125;&#125;\n    &lt;input type=&quot;text&quot; v-model=&quot;student.age&quot;&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p> 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新</p>\n<p><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/1.png\" alt=\"在这里插入图片描述\"><br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/2.png\" alt=\"在这里插入图片描述\"><br>在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化</p>\n<p>那么，我们该如何解决这个问题呢<br>解决这个问题的方法大体有两种：</p>\n<ol>\n<li>使用this.$set(obj, key, value)&#x2F;vue.set(obj, key, value)</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n data() &#123;\n   return &#123;\n     student: &#123;\n       name: &#39;张三&#39;,\n     &#125;\n   &#125;\n &#125;,\n methods: &#123;\n   setMessage() &#123;\n     this.$set(this.student, &#39;age&#39;, 15)\n     console.log(this.student)\n   &#125;\n &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>通过Object.assign(target, sources)方法</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      this.student = Object.assign(&#123;&#125;, this.student)\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p>我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦<br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/3.png\" alt=\"在这里插入图片描述\"></p>\n","excerpt":"","more":"<h2 id=\"this-set-obj-key-value\"><a href=\"#this-set-obj-key-value\" class=\"headerlink\" title=\"this.#set(obj, key, value)\"></a>this.#set(obj, key, value)</h2><p>我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性</p>\n<pre><code class=\"javascript\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;button @click=&quot;setMessage&quot;&gt;添加属性&lt;/button&gt;\n    &#123;&#123; student.name &#125;&#125;\n    &lt;input type=&quot;text&quot; v-model=&quot;student.age&quot;&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p> 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新</p>\n<p><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/1.png\" alt=\"在这里插入图片描述\"><br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/2.png\" alt=\"在这里插入图片描述\"><br>在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化</p>\n<p>那么，我们该如何解决这个问题呢<br>解决这个问题的方法大体有两种：</p>\n<ol>\n<li>使用this.$set(obj, key, value)&#x2F;vue.set(obj, key, value)</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n data() &#123;\n   return &#123;\n     student: &#123;\n       name: &#39;张三&#39;,\n     &#125;\n   &#125;\n &#125;,\n methods: &#123;\n   setMessage() &#123;\n     this.$set(this.student, &#39;age&#39;, 15)\n     console.log(this.student)\n   &#125;\n &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>通过Object.assign(target, sources)方法</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      this.student = Object.assign(&#123;&#125;, this.student)\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p>我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦<br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/3.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"如何判断一个字符串格式是否为JSON字符串","date":"2024-07-25T03:33:56.000Z","description":"如何判断一个字符串格式是否为JSON字符串\n","_content":"\n代码如下：\n````javascript\nfunction isJSON(str) {\n    if (typeof str == 'string') {\n        try {\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == '[object Object]' && obj ){\n                return true;\n            }else{\n                return false;\n            }\n\n        } catch(e) {\n            console.log('error：'+str+'!!!'+e);\n            return false;\n        }\n    }\n    console.log('It is not a string!')\n}\n````","source":"_posts/5-判断一个字符串格式是否为JSON字符串.md","raw":"---\ntitle: 如何判断一个字符串格式是否为JSON字符串\ndate: 2024-07-25 11:33:56\ntags:\n    [js]\ncategories: \n    - web前端\ndescription: |\n    如何判断一个字符串格式是否为JSON字符串\n---\n\n代码如下：\n````javascript\nfunction isJSON(str) {\n    if (typeof str == 'string') {\n        try {\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == '[object Object]' && obj ){\n                return true;\n            }else{\n                return false;\n            }\n\n        } catch(e) {\n            console.log('error：'+str+'!!!'+e);\n            return false;\n        }\n    }\n    console.log('It is not a string!')\n}\n````","slug":"5-判断一个字符串格式是否为JSON字符串","published":1,"updated":"2024-07-25T03:35:21.440Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5p000dy4vcdo8pfcq0","content":"<p>代码如下：</p>\n<pre><code class=\"javascript\">function isJSON(str) &#123;\n    if (typeof str == &#39;string&#39;) &#123;\n        try &#123;\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == &#39;[object Object]&#39; &amp;&amp; obj )&#123;\n                return true;\n            &#125;else&#123;\n                return false;\n            &#125;\n\n        &#125; catch(e) &#123;\n            console.log(&#39;error：&#39;+str+&#39;!!!&#39;+e);\n            return false;\n        &#125;\n    &#125;\n    console.log(&#39;It is not a string!&#39;)\n&#125;\n</code></pre>\n","excerpt":"","more":"<p>代码如下：</p>\n<pre><code class=\"javascript\">function isJSON(str) &#123;\n    if (typeof str == &#39;string&#39;) &#123;\n        try &#123;\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == &#39;[object Object]&#39; &amp;&amp; obj )&#123;\n                return true;\n            &#125;else&#123;\n                return false;\n            &#125;\n\n        &#125; catch(e) &#123;\n            console.log(&#39;error：&#39;+str+&#39;!!!&#39;+e);\n            return false;\n        &#125;\n    &#125;\n    console.log(&#39;It is not a string!&#39;)\n&#125;\n</code></pre>\n"},{"title":"微信小程序 IOS中new Date()时间格式不兼容问题","date":"2024-07-25T03:37:36.000Z","description":"##### 问题描述：\n - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n","_content":"##### 问题描述：\n - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n##### 解决方案：\n - 这里主要兼容问题在于Android可以处理 =='-'== 与 =='/'==  ，而IOS只能处理 =='/'== 的时间格式，具体如下：\n ```javascript\n \t/** 问题描述 */\n    let dateStr1 = '2022-12-12';\n    let dateStr2 = '2022-12-12 00:00';\n    let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n    let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n    /** 解决办法 - 将时间格式转换为 /  */\n    let date3 = new Date(dateStr2.replace(/-/g, '/'));  // 此时 IOS 和 Android 都可以正常显示了\n```\n##### 总结：\n - 这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。\n","source":"_posts/6-微信小程序IOS时间格式不兼容问题.md","raw":"---\ntitle: 微信小程序 IOS中new Date()时间格式不兼容问题\ndate: 2024-07-25 11:37:36\ntags:\n    [js, 微信小程序, IOS]\ncategories: \n    - web前端\ndescription: |\n    ##### 问题描述：\n     - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n---\n##### 问题描述：\n - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n##### 解决方案：\n - 这里主要兼容问题在于Android可以处理 =='-'== 与 =='/'==  ，而IOS只能处理 =='/'== 的时间格式，具体如下：\n ```javascript\n \t/** 问题描述 */\n    let dateStr1 = '2022-12-12';\n    let dateStr2 = '2022-12-12 00:00';\n    let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n    let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n    /** 解决办法 - 将时间格式转换为 /  */\n    let date3 = new Date(dateStr2.replace(/-/g, '/'));  // 此时 IOS 和 Android 都可以正常显示了\n```\n##### 总结：\n - 这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。\n","slug":"6-微信小程序IOS时间格式不兼容问题","published":1,"updated":"2024-07-25T03:39:48.057Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5r000hy4vc6vdb95jp","content":"<h5 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h5><ul>\n<li>最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。</li>\n</ul>\n<h5 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h5><ul>\n<li>这里主要兼容问题在于Android可以处理 &#x3D;&#x3D;’-‘&#x3D;&#x3D; 与 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D;  ，而IOS只能处理 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D; 的时间格式，具体如下：</li>\n</ul>\n<pre><code class=\"javascript\">    /** 问题描述 */\n   let dateStr1 = &#39;2022-12-12&#39;;\n   let dateStr2 = &#39;2022-12-12 00:00&#39;;\n   let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n   let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n   /** 解决办法 - 将时间格式转换为 /  */\n   let date3 = new Date(dateStr2.replace(/-/g, &#39;/&#39;));  // 此时 IOS 和 Android 都可以正常显示了\n</code></pre>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><ul>\n<li>这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。</li>\n</ul>\n","excerpt":"","more":"<h5 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h5><ul>\n<li>最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。</li>\n</ul>\n<h5 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h5><ul>\n<li>这里主要兼容问题在于Android可以处理 &#x3D;&#x3D;’-‘&#x3D;&#x3D; 与 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D;  ，而IOS只能处理 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D; 的时间格式，具体如下：</li>\n</ul>\n<pre><code class=\"javascript\">    /** 问题描述 */\n   let dateStr1 = &#39;2022-12-12&#39;;\n   let dateStr2 = &#39;2022-12-12 00:00&#39;;\n   let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n   let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n   /** 解决办法 - 将时间格式转换为 /  */\n   let date3 = new Date(dateStr2.replace(/-/g, &#39;/&#39;));  // 此时 IOS 和 Android 都可以正常显示了\n</code></pre>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><ul>\n<li>这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。</li>\n</ul>\n"},{"title":"vue更改props属性值报错","date":"2024-07-25T02:57:19.000Z","description":"vue更改props属性值报错\n","_content":"\n在更改props属性中的值时，会报错：\n>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"tableData\"\n\n<br>\n<br>\n\n **原因：** props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 \n\n**解决办法：** 在子组件中复制一个副本：\n```javascript\n\t<script>\n\texport default {\n\t\tprops:['name'],\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tsonName: this.name\n\t\t\t}\n\t\t}\n\t</script>\n```\n\n将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝\n\n","source":"_posts/2-vue报错.md","raw":"---\ntitle: vue更改props属性值报错\ndate: 2024-07-25 10:57:19\ntags:\n    [vue]\ncategories: \n    - web前端\ndescription: |\n    vue更改props属性值报错\n---\n\n在更改props属性中的值时，会报错：\n>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"tableData\"\n\n<br>\n<br>\n\n **原因：** props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 \n\n**解决办法：** 在子组件中复制一个副本：\n```javascript\n\t<script>\n\texport default {\n\t\tprops:['name'],\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tsonName: this.name\n\t\t\t}\n\t\t}\n\t</script>\n```\n\n将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝\n\n","slug":"2-vue报错","published":1,"updated":"2024-07-25T03:01:03.874Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5r000ky4vc7iwg280u","content":"<p>在更改props属性中的值时，会报错：</p>\n<blockquote>\n<p>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “tableData”</p>\n</blockquote>\n<br>\n<br>\n\n<p> <strong>原因：</strong> props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 </p>\n<p><strong>解决办法：</strong> 在子组件中复制一个副本：</p>\n<pre><code class=\"javascript\">    &lt;script&gt;\n    export default &#123;\n        props:[&#39;name&#39;],\n        data() &#123;\n            return &#123;\n                sonName: this.name\n            &#125;\n        &#125;\n    &lt;/script&gt;\n</code></pre>\n<p>将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝</p>\n","excerpt":"","more":"<p>在更改props属性中的值时，会报错：</p>\n<blockquote>\n<p>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “tableData”</p>\n</blockquote>\n<br>\n<br>\n\n<p> <strong>原因：</strong> props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 </p>\n<p><strong>解决办法：</strong> 在子组件中复制一个副本：</p>\n<pre><code class=\"javascript\">    &lt;script&gt;\n    export default &#123;\n        props:[&#39;name&#39;],\n        data() &#123;\n            return &#123;\n                sonName: this.name\n            &#125;\n        &#125;\n    &lt;/script&gt;\n</code></pre>\n<p>将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝</p>\n"},{"title":"小程序1rpx边框不完美解决方案","date":"2024-07-25T03:41:27.000Z","description":"* 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n","_content":"\n##### 问题描述\n* 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n\n##### 原因\n首先先看看IOS边框缺失的问题\n> 当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失\n\n解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数\n\n然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。\n\n再回过头看导致边框缺失的具体原因是啥。\n\n在这之前需要了解下高分屏的物理像素和虚拟像素的概念\n\n简单来说物理像素是设备的实际像素\n\n虚拟像素是设备的坐标点， 可以简单理解为css像素\n\n而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。\n\n###### 解决办法\n\n我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放\n\n具体的代码如下\n\n```\n\n.border1rpx, .border1rpx_before{\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n}\n.border1rpx::after, .border1rpx_before::before{\n  content: \"\";\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n}\n.border1rpx-full { margin: -1rpx; }\n```\n\n1. 给.border1rpx的元素设置边框宽度为0\n2. 给::after伪元素宽高为两倍，边框设置2rpx，\n3. 边框其他样式继承元素的设置\n4. 然后再缩放0.5来达到边框为1rpx的效果","source":"_posts/7-小程序1rpx边框不完美解决方案.md","raw":"---\ntitle: 小程序1rpx边框不完美解决方案\ndate: 2024-07-25 11:41:27\ntags:\n    [css, 微信小程序]\ncategories: \n    - web前端\ndescription: |\n    * 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n---\n\n##### 问题描述\n* 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n\n##### 原因\n首先先看看IOS边框缺失的问题\n> 当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失\n\n解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数\n\n然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。\n\n再回过头看导致边框缺失的具体原因是啥。\n\n在这之前需要了解下高分屏的物理像素和虚拟像素的概念\n\n简单来说物理像素是设备的实际像素\n\n虚拟像素是设备的坐标点， 可以简单理解为css像素\n\n而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。\n\n###### 解决办法\n\n我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放\n\n具体的代码如下\n\n```\n\n.border1rpx, .border1rpx_before{\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n}\n.border1rpx::after, .border1rpx_before::before{\n  content: \"\";\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n}\n.border1rpx-full { margin: -1rpx; }\n```\n\n1. 给.border1rpx的元素设置边框宽度为0\n2. 给::after伪元素宽高为两倍，边框设置2rpx，\n3. 边框其他样式继承元素的设置\n4. 然后再缩放0.5来达到边框为1rpx的效果","slug":"7-小程序1rpx边框不完美解决方案","published":1,"updated":"2024-07-25T03:43:37.929Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5y001iy4vccqfs0nav","content":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>在小程序开发中，1rpx边框随处可见，如果只是简单的使用<code>border: 1rpx solid red;</code>的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。</li>\n</ul>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><p>首先先看看IOS边框缺失的问题</p>\n<blockquote>\n<p>当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失</p>\n</blockquote>\n<p>解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数</p>\n<p>然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。</p>\n<p>再回过头看导致边框缺失的具体原因是啥。</p>\n<p>在这之前需要了解下高分屏的物理像素和虚拟像素的概念</p>\n<p>简单来说物理像素是设备的实际像素</p>\n<p>虚拟像素是设备的坐标点， 可以简单理解为css像素</p>\n<p>而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。</p>\n<h6 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h6><p>我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放</p>\n<p>具体的代码如下</p>\n<pre><code>\n.border1rpx, .border1rpx_before&#123;\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n&#125;\n.border1rpx::after, .border1rpx_before::before&#123;\n  content: &quot;&quot;;\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n&#125;\n.border1rpx-full &#123; margin: -1rpx; &#125;\n</code></pre>\n<ol>\n<li>给.border1rpx的元素设置边框宽度为0</li>\n<li>给::after伪元素宽高为两倍，边框设置2rpx，</li>\n<li>边框其他样式继承元素的设置</li>\n<li>然后再缩放0.5来达到边框为1rpx的效果</li>\n</ol>\n","excerpt":"","more":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>在小程序开发中，1rpx边框随处可见，如果只是简单的使用<code>border: 1rpx solid red;</code>的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。</li>\n</ul>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><p>首先先看看IOS边框缺失的问题</p>\n<blockquote>\n<p>当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失</p>\n</blockquote>\n<p>解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数</p>\n<p>然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。</p>\n<p>再回过头看导致边框缺失的具体原因是啥。</p>\n<p>在这之前需要了解下高分屏的物理像素和虚拟像素的概念</p>\n<p>简单来说物理像素是设备的实际像素</p>\n<p>虚拟像素是设备的坐标点， 可以简单理解为css像素</p>\n<p>而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。</p>\n<h6 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h6><p>我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放</p>\n<p>具体的代码如下</p>\n<pre><code>\n.border1rpx, .border1rpx_before&#123;\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n&#125;\n.border1rpx::after, .border1rpx_before::before&#123;\n  content: &quot;&quot;;\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n&#125;\n.border1rpx-full &#123; margin: -1rpx; &#125;\n</code></pre>\n<ol>\n<li>给.border1rpx的元素设置边框宽度为0</li>\n<li>给::after伪元素宽高为两倍，边框设置2rpx，</li>\n<li>边框其他样式继承元素的设置</li>\n<li>然后再缩放0.5来达到边框为1rpx的效果</li>\n</ol>\n"},{"title":"扩大按钮点击范围","date":"2024-07-25T03:50:56.000Z","description":"有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n","_content":"\n##### css增加元素点击范围\n有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n比如页面中有一个按钮\n\n```javascript\n  <text id=\"gl1\" bindtap=\"{{lettering}}\"></text>\n```\ncss代码：\n```javascript\n #gl1{\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n}\n#gl1::before{\n    content:\"\";\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    }\n```\ncss中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧","source":"_posts/9-扩大按钮点击范围.md","raw":"---\ntitle: 扩大按钮点击范围\ndate: 2024-07-25 11:50:56\ntags:\n    [css]\ncategories: \n    - web前端\ndescription: |\n   有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n---\n\n##### css增加元素点击范围\n有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n比如页面中有一个按钮\n\n```javascript\n  <text id=\"gl1\" bindtap=\"{{lettering}}\"></text>\n```\ncss代码：\n```javascript\n #gl1{\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n}\n#gl1::before{\n    content:\"\";\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    }\n```\ncss中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧","slug":"9-扩大按钮点击范围","published":1,"updated":"2024-07-25T03:52:29.509Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid5z001jy4vchp1ub1ik","content":"<h5 id=\"css增加元素点击范围\"><a href=\"#css增加元素点击范围\" class=\"headerlink\" title=\"css增加元素点击范围\"></a>css增加元素点击范围</h5><p>有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。<br>比如页面中有一个按钮</p>\n<pre><code class=\"javascript\">  &lt;text id=&quot;gl1&quot; bindtap=&quot;&#123;&#123;lettering&#125;&#125;&quot;&gt;&lt;/text&gt;\n</code></pre>\n<p>css代码：</p>\n<pre><code class=\"javascript\"> #gl1&#123;\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n&#125;\n#gl1::before&#123;\n    content:&quot;&quot;;\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    &#125;\n</code></pre>\n<p>css中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧</p>\n","excerpt":"","more":"<h5 id=\"css增加元素点击范围\"><a href=\"#css增加元素点击范围\" class=\"headerlink\" title=\"css增加元素点击范围\"></a>css增加元素点击范围</h5><p>有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。<br>比如页面中有一个按钮</p>\n<pre><code class=\"javascript\">  &lt;text id=&quot;gl1&quot; bindtap=&quot;&#123;&#123;lettering&#125;&#125;&quot;&gt;&lt;/text&gt;\n</code></pre>\n<p>css代码：</p>\n<pre><code class=\"javascript\"> #gl1&#123;\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n&#125;\n#gl1::before&#123;\n    content:&quot;&quot;;\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    &#125;\n</code></pre>\n<p>css中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧</p>\n"},{"title":"git无法连接远程仓库（GitHub）","date":"2024-07-25T03:44:15.000Z","description":"git报错ssh: connect to host github.com port 22: Connection timed out\n","_content":"\n##### 问题描述\n - 某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时....\n\n![在这里插入图片描述](./1.png)\n通过查阅资料尝试了几种方法之后解决了，在这做个记录。\n\n###### 解决方法\n\n首先需要检查一下SSH是否能够连接成功，输入以下命令\n```\nssh -T git@github.com\n```\n若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法\n\n 1. 打开git bash 命令行窗口，找到密钥生成位置\n \t```\n \tcd ~/.ssh\n \t```\n \t如果找不到，则需要确认是否生成并配置了ssh\n 2. 查看文件是否存在\n\t ```\n\tls\n\t ```\n 3. 若存在则在继续在终端输入以下命令新建一个文件\n \t```\n \tvim config\n \t```\n 4. 接着输入下面内容\n \t```\n \tHost github.com\n\tUser 注册github的邮箱\n\tHostname ssh.github.com\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/id_rsa\n\tPort 443\n \t```\n\t![在这里插入图片描述](./2.png)\n 5. 最后:ZZ退出编辑即可\n\n###### 验证\n\n - `ssh -T git@github.com`\n - 出现提示yes回车即可\n ![在这里插入图片描述](./3.png)\n 验证就能顺利通过了","source":"_posts/8-git无法连接远程仓库（GitHub）.md","raw":"---\ntitle: git无法连接远程仓库（GitHub）\ndate: 2024-07-25 11:44:15\ntags:\n    [git]\ncategories: \n    - 工具\ndescription: |\n   git报错ssh: connect to host github.com port 22: Connection timed out\n---\n\n##### 问题描述\n - 某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时....\n\n![在这里插入图片描述](./1.png)\n通过查阅资料尝试了几种方法之后解决了，在这做个记录。\n\n###### 解决方法\n\n首先需要检查一下SSH是否能够连接成功，输入以下命令\n```\nssh -T git@github.com\n```\n若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法\n\n 1. 打开git bash 命令行窗口，找到密钥生成位置\n \t```\n \tcd ~/.ssh\n \t```\n \t如果找不到，则需要确认是否生成并配置了ssh\n 2. 查看文件是否存在\n\t ```\n\tls\n\t ```\n 3. 若存在则在继续在终端输入以下命令新建一个文件\n \t```\n \tvim config\n \t```\n 4. 接着输入下面内容\n \t```\n \tHost github.com\n\tUser 注册github的邮箱\n\tHostname ssh.github.com\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/id_rsa\n\tPort 443\n \t```\n\t![在这里插入图片描述](./2.png)\n 5. 最后:ZZ退出编辑即可\n\n###### 验证\n\n - `ssh -T git@github.com`\n - 出现提示yes回车即可\n ![在这里插入图片描述](./3.png)\n 验证就能顺利通过了","slug":"8-git无法连接远程仓库（GitHub）","published":1,"updated":"2024-07-25T03:50:05.206Z","comments":1,"layout":"post","photos":[],"_id":"clz1zid60001ly4vc7dcy8t2o","content":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时….</li>\n</ul>\n<p><img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/1.png\" alt=\"在这里插入图片描述\"><br>通过查阅资料尝试了几种方法之后解决了，在这做个记录。</p>\n<h6 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h6><p>首先需要检查一下SSH是否能够连接成功，输入以下命令</p>\n<pre><code>ssh -T git@github.com\n</code></pre>\n<p>若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法</p>\n<ol>\n<li>打开git bash 命令行窗口，找到密钥生成位置<pre><code>cd ~/.ssh\n</code></pre>\n 如果找不到，则需要确认是否生成并配置了ssh</li>\n<li>查看文件是否存在<pre><code>ls\n</code></pre>\n</li>\n<li>若存在则在继续在终端输入以下命令新建一个文件<pre><code>vim config\n</code></pre>\n</li>\n<li>接着输入下面内容<pre><code>Host github.com\nUser 注册github的邮箱\nHostname ssh.github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\nPort 443\n</code></pre>\n<img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/2.png\" alt=\"在这里插入图片描述\"></li>\n<li>最后:ZZ退出编辑即可</li>\n</ol>\n<h6 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h6><ul>\n<li><code>ssh -T git@github.com</code></li>\n<li>出现提示yes回车即可<br> <img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/3.png\" alt=\"在这里插入图片描述\"><br> 验证就能顺利通过了</li>\n</ul>\n","excerpt":"","more":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时….</li>\n</ul>\n<p><img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/1.png\" alt=\"在这里插入图片描述\"><br>通过查阅资料尝试了几种方法之后解决了，在这做个记录。</p>\n<h6 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h6><p>首先需要检查一下SSH是否能够连接成功，输入以下命令</p>\n<pre><code>ssh -T git@github.com\n</code></pre>\n<p>若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法</p>\n<ol>\n<li>打开git bash 命令行窗口，找到密钥生成位置<pre><code>cd ~/.ssh\n</code></pre>\n 如果找不到，则需要确认是否生成并配置了ssh</li>\n<li>查看文件是否存在<pre><code>ls\n</code></pre>\n</li>\n<li>若存在则在继续在终端输入以下命令新建一个文件<pre><code>vim config\n</code></pre>\n</li>\n<li>接着输入下面内容<pre><code>Host github.com\nUser 注册github的邮箱\nHostname ssh.github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\nPort 443\n</code></pre>\n<img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/2.png\" alt=\"在这里插入图片描述\"></li>\n<li>最后:ZZ退出编辑即可</li>\n</ol>\n<h6 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h6><ul>\n<li><code>ssh -T git@github.com</code></li>\n<li>出现提示yes回车即可<br> <img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/3.png\" alt=\"在这里插入图片描述\"><br> 验证就能顺利通过了</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/3-Vue-set的正确使用/1.png","post":"clz1zid5p000cy4vc7jwj7pkz","slug":"1.png","modified":1,"renderable":0},{"_id":"source/_posts/3-Vue-set的正确使用/2.png","post":"clz1zid5p000cy4vc7jwj7pkz","slug":"2.png","modified":1,"renderable":0},{"_id":"source/_posts/3-Vue-set的正确使用/3.png","post":"clz1zid5p000cy4vc7jwj7pkz","slug":"3.png","modified":1,"renderable":0},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/1.png","post":"clz1zid60001ly4vc7dcy8t2o","slug":"1.png","modified":1,"renderable":0},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/2.png","post":"clz1zid60001ly4vc7dcy8t2o","slug":"2.png","modified":1,"renderable":0},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/3.png","post":"clz1zid60001ly4vc7dcy8t2o","slug":"3.png","modified":1,"renderable":0}],"PostCategory":[{"post_id":"clz1zid5n0008y4vcddwr54vf","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5q000ey4vc6kdyazz8"},{"post_id":"clz1zid5h0001y4vc3z9zeo6i","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5r000iy4vc3gmc3gws"},{"post_id":"clz1zid5n0009y4vc31p3hg5b","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5s000ly4vc65b7fb9n"},{"post_id":"clz1zid5p000cy4vc7jwj7pkz","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5t000oy4vchdiv0xsl"},{"post_id":"clz1zid5j0003y4vccsaxbbx2","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5t000py4vc77xz0g6q"},{"post_id":"clz1zid5p000dy4vcdo8pfcq0","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5t000ry4vc9lnfgy8i"},{"post_id":"clz1zid5r000hy4vc6vdb95jp","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5t000ty4vce52zftty"},{"post_id":"clz1zid5m0007y4vcew5u8s06","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5u000wy4vcalmghfhv"},{"post_id":"clz1zid5r000ky4vc7iwg280u","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid5u000xy4vc9izi1tfy"},{"post_id":"clz1zid5y001iy4vccqfs0nav","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid60001my4vc09dq84pp"},{"post_id":"clz1zid5z001jy4vchp1ub1ik","category_id":"clz1zid5k0004y4vcdpie9kpi","_id":"clz1zid60001oy4vcg2hggg84"},{"post_id":"clz1zid60001ly4vc7dcy8t2o","category_id":"clz1zid60001ny4vccmc32fvf","_id":"clz1zid61001uy4vc1822fesn"}],"PostTag":[{"post_id":"clz1zid5h0001y4vc3z9zeo6i","tag_id":"clz1zid5l0005y4vc8f3sfmpf","_id":"clz1zid5r000jy4vcg4jng650"},{"post_id":"clz1zid5h0001y4vc3z9zeo6i","tag_id":"clz1zid5o000by4vc8fx8hqn9","_id":"clz1zid5s000my4vcf4yu8hd8"},{"post_id":"clz1zid5j0003y4vccsaxbbx2","tag_id":"clz1zid5q000gy4vcdy1efhrr","_id":"clz1zid5t000sy4vc0u43fngt"},{"post_id":"clz1zid5j0003y4vccsaxbbx2","tag_id":"clz1zid5t000ny4vc0y78hd05","_id":"clz1zid5t000uy4vc78vfcumw"},{"post_id":"clz1zid5m0007y4vcew5u8s06","tag_id":"clz1zid5l0005y4vc8f3sfmpf","_id":"clz1zid5u000zy4vc3evocbuo"},{"post_id":"clz1zid5m0007y4vcew5u8s06","tag_id":"clz1zid5o000by4vc8fx8hqn9","_id":"clz1zid5u0010y4vc2a29hafn"},{"post_id":"clz1zid5n0008y4vcddwr54vf","tag_id":"clz1zid5u000yy4vcc41ag3py","_id":"clz1zid5u0012y4vc563560d3"},{"post_id":"clz1zid5n0009y4vc31p3hg5b","tag_id":"clz1zid5u0011y4vc3wo91iwf","_id":"clz1zid5v0015y4vchhkycrq1"},{"post_id":"clz1zid5n0009y4vc31p3hg5b","tag_id":"clz1zid5v0013y4vc88ptheeo","_id":"clz1zid5v0016y4vc7i7x72zk"},{"post_id":"clz1zid5p000cy4vc7jwj7pkz","tag_id":"clz1zid5u0011y4vc3wo91iwf","_id":"clz1zid5v0018y4vc7jdu6n16"},{"post_id":"clz1zid5p000dy4vcdo8pfcq0","tag_id":"clz1zid5t000ny4vc0y78hd05","_id":"clz1zid5w001ay4vc4fnk4e5s"},{"post_id":"clz1zid5r000hy4vc6vdb95jp","tag_id":"clz1zid5t000ny4vc0y78hd05","_id":"clz1zid5w001ey4vc9ksf2jop"},{"post_id":"clz1zid5r000hy4vc6vdb95jp","tag_id":"clz1zid5w001by4vcf9bn7icc","_id":"clz1zid5w001fy4vccw2deqm5"},{"post_id":"clz1zid5r000hy4vc6vdb95jp","tag_id":"clz1zid5w001cy4vcca2leoxf","_id":"clz1zid5w001gy4vcajgb7o5z"},{"post_id":"clz1zid5r000ky4vc7iwg280u","tag_id":"clz1zid5u0011y4vc3wo91iwf","_id":"clz1zid5w001hy4vc2t7d4g2i"},{"post_id":"clz1zid5y001iy4vccqfs0nav","tag_id":"clz1zid5z001ky4vcbovwhv9g","_id":"clz1zid61001qy4vc6a9x0nbz"},{"post_id":"clz1zid5y001iy4vccqfs0nav","tag_id":"clz1zid5w001by4vcf9bn7icc","_id":"clz1zid61001ry4vchm40bouk"},{"post_id":"clz1zid5z001jy4vchp1ub1ik","tag_id":"clz1zid5z001ky4vcbovwhv9g","_id":"clz1zid61001ty4vcgf4u1yia"},{"post_id":"clz1zid60001ly4vc7dcy8t2o","tag_id":"clz1zid61001sy4vcbnwagv4b","_id":"clz1zid61001vy4vcgp1a4jye"}],"Tag":[{"name":"canvas","_id":"clz1zid5l0005y4vc8f3sfmpf"},{"name":"html2canvas","_id":"clz1zid5o000by4vc8fx8hqn9"},{"name":"es6","_id":"clz1zid5q000gy4vcdy1efhrr"},{"name":"js","_id":"clz1zid5t000ny4vc0y78hd05"},{"name":"小程序","_id":"clz1zid5u000yy4vcc41ag3py"},{"name":"vue","_id":"clz1zid5u0011y4vc3wo91iwf"},{"name":"element-ui","_id":"clz1zid5v0013y4vc88ptheeo"},{"name":"微信小程序","_id":"clz1zid5w001by4vcf9bn7icc"},{"name":"IOS","_id":"clz1zid5w001cy4vcca2leoxf"},{"name":"css","_id":"clz1zid5z001ky4vcbovwhv9g"},{"name":"git","_id":"clz1zid61001sy4vcbnwagv4b"}]}}