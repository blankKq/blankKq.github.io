{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/particlex/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background.jpg","path":"images/background.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background.png","path":"images/background.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/css/cursor.min.css","path":"css/cursor.min.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/background.js","path":"js/lib/background.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/cursor.min.js","path":"js/lib/cursor.min.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/fireworks.js","path":"js/lib/fireworks.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/1-es6-let-const.md","hash":"6904a2661f44d4a923eeef113ce9e3d407f39774","modified":1721876002988},{"_id":"source/_posts/2-vue报错.md","hash":"3955c18cc2079de5d9864170153b4dcee8ae9f1c","modified":1721876463874},{"_id":"source/_posts/4-vue为element-ui组件事件添加自定义参数.md","hash":"748645a135879ab5bee15e1d1998501b55b99b3f","modified":1721878529644},{"_id":"source/_posts/6-微信小程序IOS时间格式不兼容问题.md","hash":"5d45c38a52726368458e161994d50b44d03a74bc","modified":1721878788057},{"_id":"source/_posts/5-判断一个字符串格式是否为JSON字符串.md","hash":"eb14325a9403c1e32987097eec557f7d5513a43e","modified":1721878521440},{"_id":"source/_posts/3-Vue-set的正确使用.md","hash":"9179a0163ab45138808a8e54447eef1596895444","modified":1721878339192},{"_id":"source/tags/index.md","hash":"376e199366dae7fcd56352b3cb7ed74280a412a1","modified":1721800622594},{"_id":"source/_posts/7-小程序1rpx边框不完美解决方案.md","hash":"c0af409f0c9879ac09ac1603214ca5c3b19b19a4","modified":1721879017929},{"_id":"source/categories/index.md","hash":"6b1bbf970b5f4e9cc88670e4fb3ecf283cdb57ff","modified":1721801190322},{"_id":"source/_posts/3-Vue-set的正确使用/2.png","hash":"3b3c3529a39b8548a04e5e4c9c74a91f32244adc","modified":1721877354409},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）.md","hash":"4e65c1cbbfe56a5f25c16a177620774f7f55f069","modified":1721879405206},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/2.png","hash":"a2ddbf0ed323c6289584bfaf7f32bbb6d6830b22","modified":1721879232902},{"_id":"source/_posts/3-Vue-set的正确使用/1.png","hash":"c1bb7ab95fd7b0f2121d217621ee79e838d2c0e9","modified":1721877275121},{"_id":"source/_posts/9-扩大按钮点击范围.md","hash":"0a7bdc2d48cd6db43b0aafc1dc6b56e3cfc76c0e","modified":1721879549509},{"_id":"source/_posts/3-Vue-set的正确使用/3.png","hash":"bfcd2be301f48fc106fb19ef929008128e576ddd","modified":1721877300205},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/3.png","hash":"fd6fbb9bc215a1a04b248caf091c91da1053c0ca","modified":1721879259404},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/1.png","hash":"7afa746f702580652adc32462a74354004318f72","modified":1721879199096},{"_id":"themes/particlex/.gitignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1721716900455},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1721716900455},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1721716900457},{"_id":"themes/particlex/_config.yml","hash":"e165b784f5940ff98d4c8706c261a7c8127d6e35","modified":1721874087811},{"_id":"themes/particlex/package.json","hash":"cf27e24dcd81559d6d2537eba0582259f17817dd","modified":1721716900461},{"_id":"themes/particlex/README.md","hash":"19b124670bc5c9aa8cff0fc191be1e9a40c841a0","modified":1721716900457},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"a29c2c1fca9c5dd49efe1452c9f44f56957967fa","modified":1721716900461},{"_id":"themes/particlex/layout/archives.ejs","hash":"c3878ffe435aa37ba46a0ee25c34257c2f2a1d87","modified":1721716900457},{"_id":"themes/particlex/layout/card.ejs","hash":"65e0c46a79c02212982c8a9aef1b16bfc3430429","modified":1721716900457},{"_id":"themes/particlex/layout/categories.ejs","hash":"73ff20a582c72e7cf138c7b42006447e4a2e110a","modified":1721716900457},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1721726939068},{"_id":"themes/particlex/layout/current.ejs","hash":"4e75c06c9d0b1336c69c210567581e7efded5621","modified":1721716900457},{"_id":"themes/particlex/layout/footer.ejs","hash":"357b2db2eab031150e06dd47695dc9916d875fc4","modified":1721716900457},{"_id":"themes/particlex/layout/index.ejs","hash":"e7c208f1d9c0acb24f20180ffa45f48ee5ea5d71","modified":1721716900461},{"_id":"themes/particlex/layout/import.ejs","hash":"7800720150b46a9abaf513316602a05293b3991b","modified":1721716900461},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1721716900461},{"_id":"themes/particlex/layout/layout.ejs","hash":"3fbfd1c29218b8d114c3cb9f2cf69b2285573658","modified":1721868258003},{"_id":"themes/particlex/.github/dependabot.yml","hash":"d2adc8df9ae7f28520d2fd5c0579e75dbe352bdc","modified":1721781677099},{"_id":"themes/particlex/layout/posts.ejs","hash":"c0d92ea2589d69522805daad16add5265a24a04d","modified":1721718561742},{"_id":"themes/particlex/layout/post.ejs","hash":"a3e567ac00d1ccd8a84525d20665318248da75a7","modified":1721716900461},{"_id":"themes/particlex/layout/tags.ejs","hash":"f5b821d45f2f44443adade62eb032f92215e0d62","modified":1721716900461},{"_id":"themes/particlex/source/images/avatar.jpg","hash":"6faa2a42a3c99fbfa775df57861ccaf879e95596","modified":1721718893910},{"_id":"themes/particlex/source/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1721716900473},{"_id":"themes/particlex/source/css/cursor.min.css","hash":"c5040cf6c867593f9629a10b27fe9777d1b4ed19","modified":1721868219399},{"_id":"themes/particlex/source/css/main.css","hash":"ff49d90e3eb12de20b68a95c028a44d8d5f28a2e","modified":1721716900465},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1721716900478},{"_id":"themes/particlex/source/js/lib/background.js","hash":"3d1201d64f26b680554e760f14267f0b076535d2","modified":1721868192293},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/cursor.min.js","hash":"de87e022db21f014841f93203a36e3db0942de2f","modified":1721868105905},{"_id":"themes/particlex/source/js/lib/fireworks.js","hash":"ad0f621562aad099ceff52e5943f951ce50e7ae7","modified":1721868203825},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"9631a74681b34ff1247837a338269f3c5efba45c","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1721716900475},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1721716900478},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1721716900475},{"_id":"themes/particlex/source/images/background.png","hash":"e9ac27f2c219f209061720fd986a9baf36b6ecb4","modified":1721719078562},{"_id":"themes/particlex/source/images/background.jpg","hash":"d4cd5b1193bcf15f9420ee92a321ab62b5b8c452","modified":1721716900473},{"_id":"public/categories/index.html","hash":"1e33fe2440f8741d54ada8c40c140df35205b015","modified":1721888447499},{"_id":"public/tags/index.html","hash":"30042bf3745c3e9e41172b3a34aecbed5e1c0282","modified":1721888447499},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/index.html","hash":"893a99d8d1bb4ede9b4723b3b856cd4f415ecf98","modified":1721888447499},{"_id":"public/2024/07/25/7-小程序1rpx边框不完美解决方案/index.html","hash":"fd5bea3ea162318993970578e8c816181e63ffd4","modified":1721888447499},{"_id":"public/2024/07/25/6-微信小程序IOS时间格式不兼容问题/index.html","hash":"c40f826ba86a71355bd2a769140e7cd9539d8ddb","modified":1721888447499},{"_id":"public/2024/07/25/5-判断一个字符串格式是否为JSON字符串/index.html","hash":"386089f69842b231c62b3bbf180b7130911cd569","modified":1721888447499},{"_id":"public/2024/07/25/4-vue为element-ui组件事件添加自定义参数/index.html","hash":"abd4bd82e967a61f256942b57f8119715a754ecd","modified":1721888447499},{"_id":"public/2024/07/25/3-Vue-set的正确使用/index.html","hash":"ba9f32492de9bff9ebc31564e775ad40873f226b","modified":1721888447499},{"_id":"public/2024/07/25/2-vue报错/index.html","hash":"43ddc19234f3bf59def8eb1106f74c043b67b48e","modified":1721888447499},{"_id":"public/2024/07/24/1-es6-let-const/index.html","hash":"dba7201bec1b185d01b80fc30d682685c4705a69","modified":1721888447499},{"_id":"public/categories/工具/index.html","hash":"0189e2ef5608c7a45b792eb94676b571ca0d84d8","modified":1721888447499},{"_id":"public/tags/es6/index.html","hash":"987d7b49e7caac742ffb715a5b697aea2a3865b0","modified":1721888447499},{"_id":"public/tags/js/index.html","hash":"281267290c7f75540b88800f6afcf7c0c9c05759","modified":1721888447499},{"_id":"public/tags/vue/index.html","hash":"ea93c496a700252f8520f5dbc4c09c60e7e157f0","modified":1721888447499},{"_id":"public/tags/element-ui/index.html","hash":"c9dfbb18d352fac6b8566a170855f123bb72d20f","modified":1721888447499},{"_id":"public/tags/微信小程序/index.html","hash":"ea0561ae807f69940b282f20ebc7d573cce59cba","modified":1721888447499},{"_id":"public/tags/IOS/index.html","hash":"7583b35214fce2cbc7d154b583625d21a32f62e8","modified":1721888447499},{"_id":"public/tags/css/index.html","hash":"53b5e05f0c318e5e87794396ee73450ad818c81b","modified":1721888447499},{"_id":"public/tags/git/index.html","hash":"b6489554093a790289ecaf3949807768d410673e","modified":1721888447499},{"_id":"public/categories/web前端/index.html","hash":"2a46eb135f034180fa91ed1e32c96c87633f1cbc","modified":1721888447499},{"_id":"public/index.html","hash":"6230b4a6408b6f2fd91ec5a78e7cc76591027701","modified":1721888447499},{"_id":"public/archives/index.html","hash":"f589a224875c631e6376a9a787588f06b0693f48","modified":1721888447499},{"_id":"public/images/avatar.jpg","hash":"6faa2a42a3c99fbfa775df57861ccaf879e95596","modified":1721888447499},{"_id":"public/2024/07/25/9-扩大按钮点击范围/index.html","hash":"56b81a2e1893538d92ead7f774d643cf65b1aa82","modified":1721888447499},{"_id":"public/archives/2024/index.html","hash":"8287024cf0972bf4bc3fbec954fe01aa4cae515d","modified":1721888447499},{"_id":"public/archives/2024/07/index.html","hash":"f7200609c1561fcdf6772fd4429944f32d8390c1","modified":1721888447499},{"_id":"public/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1721888447499},{"_id":"public/2024/07/25/3-Vue-set的正确使用/1.png","hash":"c1bb7ab95fd7b0f2121d217621ee79e838d2c0e9","modified":1721888447499},{"_id":"public/2024/07/25/3-Vue-set的正确使用/3.png","hash":"bfcd2be301f48fc106fb19ef929008128e576ddd","modified":1721888447499},{"_id":"public/2024/07/25/3-Vue-set的正确使用/2.png","hash":"3b3c3529a39b8548a04e5e4c9c74a91f32244adc","modified":1721888447499},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/2.png","hash":"a2ddbf0ed323c6289584bfaf7f32bbb6d6830b22","modified":1721888447499},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/3.png","hash":"fd6fbb9bc215a1a04b248caf091c91da1053c0ca","modified":1721888447499},{"_id":"public/2024/07/25/8-git无法连接远程仓库（GitHub）/1.png","hash":"7afa746f702580652adc32462a74354004318f72","modified":1721888447499},{"_id":"public/css/cursor.min.css","hash":"24aabac400205b91eac7ddf0e5df6a06114e7a67","modified":1721888447499},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1721888447499},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1721888447499},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1721888447499},{"_id":"public/js/lib/cursor.min.js","hash":"9b0cdeeb043f35cfc863a24852a9fcbcd6d997e7","modified":1721888447499},{"_id":"public/js/lib/fireworks.js","hash":"7b2691741d815b3ca017b302b498501aa8591589","modified":1721888447499},{"_id":"public/js/lib/background.js","hash":"846e3547d0b7bb2aa888bcd0b45a9b78ed75c11f","modified":1721888447499},{"_id":"public/js/lib/highlight.js","hash":"c2b4c59c24728fc35dfa6339a1716d9897dcffe7","modified":1721888447499},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1721888447499},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1721888447499},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1721888447499},{"_id":"public/css/main.css","hash":"444ff8856c320913dde037c43f24bba18ef4d741","modified":1721888447499},{"_id":"public/images/background.png","hash":"e9ac27f2c219f209061720fd986a9baf36b6ecb4","modified":1721888447499},{"_id":"public/images/background.jpg","hash":"d4cd5b1193bcf15f9420ee92a321ab62b5b8c452","modified":1721888447499}],"Category":[{"name":"web前端","_id":"clz0vx9zr0004l8vc0vvv70cr"},{"name":"工具","_id":"clz0vxa040019l8vc63ahdybk"}],"Data":[],"Page":[{"title":"categories","date":"2024-07-24T05:53:36.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-07-24 13:53:36\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2024-07-24T06:06:30.322Z","path":"categories/index.html","comments":1,"_id":"clz0vx9zm0000l8vcfvtp6mvj","content":"","excerpt":"","more":""},{"title":"tags","date":"2024-07-24T05:55:03.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2024-07-24 13:55:03\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2024-07-24T05:57:02.594Z","path":"tags/index.html","comments":1,"_id":"clz0vx9zq0002l8vcdmqu7g2w","content":"","excerpt":"","more":""}],"Post":[{"title":"es6之let，const的使用","date":"2024-07-24T12:34:18.000Z","description":"es6之let，const新特性\n","_content":"\n# let，const的一些特点\n\n 1. 使用let或者const定义会形成块级作用域，一个{}就是一个作用域\n 2. let，const没有与解析\n 3. 同一个作用域下不能同时定义同一个变量\n 4. for循环时使用let来定义变量\n\n \t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      console.log(i) // 0 1 2 3 4 \n    }\n    alert(i) // 报错，i is not defined\n\t```\n\t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      let i = 'i 是否已经被定义了？'\n      console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = 'i 是否已经被定义了？'并没有在同一个作用域下\n    }\n\t```\n\t从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域\n5. 暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的\n\t```javascript\n\t// 暂时性死区\n    a = 30; // 暂时性死区开始(ReferenceError)\n    alert(a)  // ReferenceError\n    alert(b) // ReferenceError\n    let a = 10; // 暂时性死区结束\n    let b = 20;\n\t```\n6. const定义的变量不能再次重新被赋值\n7. 使用const定义变量的时候必须赋值\n\t```javascript\n\tconst a ;\n    console.log(a)  //  SyntaxError: Missing initializer in const declaration\n\t```","source":"_posts/1-es6-let-const.md","raw":"---\ntitle: es6之let，const的使用\ndate: 2024-07-24 20:34:18\ntags:\n    [es6, js]\ncategories: \n    - web前端\ndescription: |\n    es6之let，const新特性\n---\n\n# let，const的一些特点\n\n 1. 使用let或者const定义会形成块级作用域，一个{}就是一个作用域\n 2. let，const没有与解析\n 3. 同一个作用域下不能同时定义同一个变量\n 4. for循环时使用let来定义变量\n\n \t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      console.log(i) // 0 1 2 3 4 \n    }\n    alert(i) // 报错，i is not defined\n\t```\n\t```javascript\n\tlet arr = [1,2,3,4,5]\n    for (let i = 0, len = arr.length; i < len; i++) {\n      let i = 'i 是否已经被定义了？'\n      console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = 'i 是否已经被定义了？'并没有在同一个作用域下\n    }\n\t```\n\t从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域\n5. 暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的\n\t```javascript\n\t// 暂时性死区\n    a = 30; // 暂时性死区开始(ReferenceError)\n    alert(a)  // ReferenceError\n    alert(b) // ReferenceError\n    let a = 10; // 暂时性死区结束\n    let b = 20;\n\t```\n6. const定义的变量不能再次重新被赋值\n7. 使用const定义变量的时候必须赋值\n\t```javascript\n\tconst a ;\n    console.log(a)  //  SyntaxError: Missing initializer in const declaration\n\t```","slug":"1-es6-let-const","published":1,"updated":"2024-07-25T02:53:22.988Z","comments":1,"layout":"post","photos":[],"_id":"clz0vx9zo0001l8vcfpj3guvc","content":"<h1 id=\"let，const的一些特点\"><a href=\"#let，const的一些特点\" class=\"headerlink\" title=\"let，const的一些特点\"></a>let，const的一些特点</h1><ol>\n<li><p>使用let或者const定义会形成块级作用域，一个{}就是一个作用域</p>\n</li>\n<li><p>let，const没有与解析</p>\n</li>\n<li><p>同一个作用域下不能同时定义同一个变量</p>\n</li>\n<li><p>for循环时使用let来定义变量</p>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n console.log(i) // 0 1 2 3 4 \n&#125;\nalert(i) // 报错，i is not defined\n</code></pre>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n  let i = &#39;i 是否已经被定义了？&#39;\n  console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = &#39;i 是否已经被定义了？&#39;并没有在同一个作用域下\n&#125;\n</code></pre>\n<p>从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域</p>\n</li>\n<li><p>暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的</p>\n<pre><code class=\"javascript\">// 暂时性死区\na = 30; // 暂时性死区开始(ReferenceError)\nalert(a)  // ReferenceError\nalert(b) // ReferenceError\nlet a = 10; // 暂时性死区结束\nlet b = 20;\n</code></pre>\n</li>\n<li><p>const定义的变量不能再次重新被赋值</p>\n</li>\n<li><p>使用const定义变量的时候必须赋值</p>\n<pre><code class=\"javascript\">const a ;\nconsole.log(a)  //  SyntaxError: Missing initializer in const declaration\n</code></pre>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"let，const的一些特点\"><a href=\"#let，const的一些特点\" class=\"headerlink\" title=\"let，const的一些特点\"></a>let，const的一些特点</h1><ol>\n<li><p>使用let或者const定义会形成块级作用域，一个{}就是一个作用域</p>\n</li>\n<li><p>let，const没有与解析</p>\n</li>\n<li><p>同一个作用域下不能同时定义同一个变量</p>\n</li>\n<li><p>for循环时使用let来定义变量</p>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n console.log(i) // 0 1 2 3 4 \n&#125;\nalert(i) // 报错，i is not defined\n</code></pre>\n<pre><code class=\"javascript\">let arr = [1,2,3,4,5]\nfor (let i = 0, len = arr.length; i &lt; len; i++) &#123;\n  let i = &#39;i 是否已经被定义了？&#39;\n  console.log(i) // 此时代码并没有报错，证明let i = 0 和let i = &#39;i 是否已经被定义了？&#39;并没有在同一个作用域下\n&#125;\n</code></pre>\n<p>从以上两段代码中可以看出来在for循环的过程中使用let定义的变量i的时候，（）也形成了一个作用域，该作用域是 { } 里边的一个父级作用域</p>\n</li>\n<li><p>暂时性死区(TDZ)：let，const定义变量的时候没有变量的声明提升，所以在定义这个变量之前是不能对这个变量进行操作的</p>\n<pre><code class=\"javascript\">// 暂时性死区\na = 30; // 暂时性死区开始(ReferenceError)\nalert(a)  // ReferenceError\nalert(b) // ReferenceError\nlet a = 10; // 暂时性死区结束\nlet b = 20;\n</code></pre>\n</li>\n<li><p>const定义的变量不能再次重新被赋值</p>\n</li>\n<li><p>使用const定义变量的时候必须赋值</p>\n<pre><code class=\"javascript\">const a ;\nconsole.log(a)  //  SyntaxError: Missing initializer in const declaration\n</code></pre>\n</li>\n</ol>\n"},{"title":"vue更改props属性值报错","date":"2024-07-25T02:57:19.000Z","description":"vue更改props属性值报错\n","_content":"\n在更改props属性中的值时，会报错：\n>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"tableData\"\n\n<br>\n<br>\n\n **原因：** props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 \n\n**解决办法：** 在子组件中复制一个副本：\n```javascript\n\t<script>\n\texport default {\n\t\tprops:['name'],\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tsonName: this.name\n\t\t\t}\n\t\t}\n\t</script>\n```\n\n将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝\n\n","source":"_posts/2-vue报错.md","raw":"---\ntitle: vue更改props属性值报错\ndate: 2024-07-25 10:57:19\ntags:\n    [vue]\ncategories: \n    - web前端\ndescription: |\n    vue更改props属性值报错\n---\n\n在更改props属性中的值时，会报错：\n>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"tableData\"\n\n<br>\n<br>\n\n **原因：** props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 \n\n**解决办法：** 在子组件中复制一个副本：\n```javascript\n\t<script>\n\texport default {\n\t\tprops:['name'],\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tsonName: this.name\n\t\t\t}\n\t\t}\n\t</script>\n```\n\n将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝\n\n","slug":"2-vue报错","published":1,"updated":"2024-07-25T03:01:03.874Z","comments":1,"layout":"post","photos":[],"_id":"clz0vx9zq0003l8vc85f37u58","content":"<p>在更改props属性中的值时，会报错：</p>\n<blockquote>\n<p>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “tableData”</p>\n</blockquote>\n<br>\n<br>\n\n<p> <strong>原因：</strong> props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 </p>\n<p><strong>解决办法：</strong> 在子组件中复制一个副本：</p>\n<pre><code class=\"javascript\">    &lt;script&gt;\n    export default &#123;\n        props:[&#39;name&#39;],\n        data() &#123;\n            return &#123;\n                sonName: this.name\n            &#125;\n        &#125;\n    &lt;/script&gt;\n</code></pre>\n<p>将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝</p>\n","excerpt":"","more":"<p>在更改props属性中的值时，会报错：</p>\n<blockquote>\n<p>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “tableData”</p>\n</blockquote>\n<br>\n<br>\n\n<p> <strong>原因：</strong> props是单向数据绑定的，当父组件中的值发生变化，会将值传导给子组件，但是不会反过来（在vue2.0中废除了props的双向数据绑定），这是为了子组件无意中修改了父组件中的状态，使应用的数据流变得难以理解 </p>\n<p><strong>解决办法：</strong> 在子组件中复制一个副本：</p>\n<pre><code class=\"javascript\">    &lt;script&gt;\n    export default &#123;\n        props:[&#39;name&#39;],\n        data() &#123;\n            return &#123;\n                sonName: this.name\n            &#125;\n        &#125;\n    &lt;/script&gt;\n</code></pre>\n<p>将值拷贝到子组件之后再进行操作，如果这里是一个复杂数据类型，则需用使用深拷贝或者JSON来进行拷贝</p>\n"},{"title":"如何为element-ui组件定义的事件添加自己的参数","date":"2024-07-25T03:31:51.000Z","description":"我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n","_content":"\n我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n\n废话不多说，直接看代码：\n这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去\n````\n<template>\n\t<div class=\"hello\">\n\t\t<div v-for=\"(item, index) in items\" :key=\"index\">\n\t\t\t<el-radio @change=\"(data) => {getdata(item.name, data)}\" v-model=\"radio\" label=\"1\">{{ item.name }}</el-radio>\n\t\t\t<el-radio v-model=\"radio\" label=\"2\">{{ item.name }}</el-radio>\n\t\t</div>\n\t</div>\n</template>\n````\n````\n<script>\nexport default {\n  data() {\n    return {\n      radio: \"1\",\n      items: [{name: 'lis'}, {name: '13'}]\n    };\n  },\n  methods: {\n    getdata(index, data) {\n      console.log(data, index);\n    }\n  },\n  mounted() {}\n};\n</script>\n````\n\n原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数\n\n\n补充：可以使用$event 来获取到事件对象e","source":"_posts/4-vue为element-ui组件事件添加自定义参数.md","raw":"---\ntitle: 如何为element-ui组件定义的事件添加自己的参数\ndate: 2024-07-25 11:31:51\ntags:\n    [vue, element-ui]\ncategories: \n    - web前端\ndescription: |\n    我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n---\n\n我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？\n\n废话不多说，直接看代码：\n这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去\n````\n<template>\n\t<div class=\"hello\">\n\t\t<div v-for=\"(item, index) in items\" :key=\"index\">\n\t\t\t<el-radio @change=\"(data) => {getdata(item.name, data)}\" v-model=\"radio\" label=\"1\">{{ item.name }}</el-radio>\n\t\t\t<el-radio v-model=\"radio\" label=\"2\">{{ item.name }}</el-radio>\n\t\t</div>\n\t</div>\n</template>\n````\n````\n<script>\nexport default {\n  data() {\n    return {\n      radio: \"1\",\n      items: [{name: 'lis'}, {name: '13'}]\n    };\n  },\n  methods: {\n    getdata(index, data) {\n      console.log(data, index);\n    }\n  },\n  mounted() {}\n};\n</script>\n````\n\n原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数\n\n\n补充：可以使用$event 来获取到事件对象e","slug":"4-vue为element-ui组件事件添加自定义参数","published":1,"updated":"2024-07-25T03:35:29.644Z","comments":1,"layout":"post","photos":[],"_id":"clz0vx9zt0006l8vc5dj240d6","content":"<p>我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？</p>\n<p>废话不多说，直接看代码：<br>这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去</p>\n<pre><code>&lt;template&gt;\n    &lt;div class=&quot;hello&quot;&gt;\n        &lt;div v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;\n            &lt;el-radio @change=&quot;(data) =&gt; &#123;getdata(item.name, data)&#125;&quot; v-model=&quot;radio&quot; label=&quot;1&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n            &lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code>&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      radio: &quot;1&quot;,\n      items: [&#123;name: &#39;lis&#39;&#125;, &#123;name: &#39;13&#39;&#125;]\n    &#125;;\n  &#125;,\n  methods: &#123;\n    getdata(index, data) &#123;\n      console.log(data, index);\n    &#125;\n  &#125;,\n  mounted() &#123;&#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数</p>\n<p>补充：可以使用$event 来获取到事件对象e</p>\n","excerpt":"","more":"<p>我们在使用element-ui组件的时候，该如何为element-ui中定义好的事件添加一些自己的参数呢？</p>\n<p>废话不多说，直接看代码：<br>这是一个简单的应用，在我们选中按钮的时候，需用将他的名字也传递过去</p>\n<pre><code>&lt;template&gt;\n    &lt;div class=&quot;hello&quot;&gt;\n        &lt;div v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;\n            &lt;el-radio @change=&quot;(data) =&gt; &#123;getdata(item.name, data)&#125;&quot; v-model=&quot;radio&quot; label=&quot;1&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n            &lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/el-radio&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code>&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      radio: &quot;1&quot;,\n      items: [&#123;name: &#39;lis&#39;&#125;, &#123;name: &#39;13&#39;&#125;]\n    &#125;;\n  &#125;,\n  methods: &#123;\n    getdata(index, data) &#123;\n      console.log(data, index);\n    &#125;\n  &#125;,\n  mounted() &#123;&#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>原理：这里形成了闭包，在点击的时候，会将change事件中默认的参数传递到匿名函数里边，然后再获取到这个参数</p>\n<p>补充：可以使用$event 来获取到事件对象e</p>\n"},{"title":"this.$set的正确使用","date":"2024-07-25T02:59:15.000Z","description":"this.$set的正确使用\n","_content":"## this.#set(obj, key, value)\n我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性\n````javascript\n<template>\n  <div class=\"hello\">\n    <button @click=\"setMessage\">添加属性</button>\n    {{ student.name }}\n    <input type=\"text\" v-model=\"student.age\">\n  </div>\n</template>\n````\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新\n \n![在这里插入图片描述](./1.png)\n![在这里插入图片描述](./2.png)\n在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化\n\n那么，我们该如何解决这个问题呢\n解决这个问题的方法大体有两种：\n\n 1. 使用this.$set(obj, key, value)/vue.set(obj, key, value)\n\n ````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.$set(this.student, 'age', 15)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n  ````\n2. 通过Object.assign(target, sources)方法\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      this.student = Object.assign({}, this.student)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦\n![在这里插入图片描述](./3.png)","source":"_posts/3-Vue-set的正确使用.md","raw":"---\ntitle: this.$set的正确使用\ndate: 2024-07-25 10:59:15\ntags:\n    [vue]\ncategories: \n    - web前端\ndescription: |\n    this.$set的正确使用\n---\n## this.#set(obj, key, value)\n我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性\n````javascript\n<template>\n  <div class=\"hello\">\n    <button @click=\"setMessage\">添加属性</button>\n    {{ student.name }}\n    <input type=\"text\" v-model=\"student.age\">\n  </div>\n</template>\n````\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新\n \n![在这里插入图片描述](./1.png)\n![在这里插入图片描述](./2.png)\n在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化\n\n那么，我们该如何解决这个问题呢\n解决这个问题的方法大体有两种：\n\n 1. 使用this.$set(obj, key, value)/vue.set(obj, key, value)\n\n ````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.$set(this.student, 'age', 15)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n  ````\n2. 通过Object.assign(target, sources)方法\n\t\n````javascript\n<script>\nexport default {\n  data() {\n    return {\n      student: {\n        name: '张三',\n      }\n    }\n  },\n  methods: {\n    setMessage() {\n      this.student.age = 15\n      this.student = Object.assign({}, this.student)\n      console.log(this.student)\n    }\n  }\n}\n</script>\n````\n\n我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦\n![在这里插入图片描述](./3.png)","slug":"3-Vue-set的正确使用","published":1,"updated":"2024-07-25T03:32:19.192Z","comments":1,"layout":"post","photos":[],"_id":"clz0vx9zt0007l8vc4n0289ok","content":"<h2 id=\"this-set-obj-key-value\"><a href=\"#this-set-obj-key-value\" class=\"headerlink\" title=\"this.#set(obj, key, value)\"></a>this.#set(obj, key, value)</h2><p>我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性</p>\n<pre><code class=\"javascript\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;button @click=&quot;setMessage&quot;&gt;添加属性&lt;/button&gt;\n    &#123;&#123; student.name &#125;&#125;\n    &lt;input type=&quot;text&quot; v-model=&quot;student.age&quot;&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p> 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新</p>\n<p><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/1.png\" alt=\"在这里插入图片描述\"><br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/2.png\" alt=\"在这里插入图片描述\"><br>在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化</p>\n<p>那么，我们该如何解决这个问题呢<br>解决这个问题的方法大体有两种：</p>\n<ol>\n<li>使用this.$set(obj, key, value)&#x2F;vue.set(obj, key, value)</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n data() &#123;\n   return &#123;\n     student: &#123;\n       name: &#39;张三&#39;,\n     &#125;\n   &#125;\n &#125;,\n methods: &#123;\n   setMessage() &#123;\n     this.$set(this.student, &#39;age&#39;, 15)\n     console.log(this.student)\n   &#125;\n &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>通过Object.assign(target, sources)方法</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      this.student = Object.assign(&#123;&#125;, this.student)\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p>我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦<br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/3.png\" alt=\"在这里插入图片描述\"></p>\n","excerpt":"","more":"<h2 id=\"this-set-obj-key-value\"><a href=\"#this-set-obj-key-value\" class=\"headerlink\" title=\"this.#set(obj, key, value)\"></a>this.#set(obj, key, value)</h2><p>我们在项目开发的过程中，经常会遇到这种情况：为data中的某一个对象添加一个属性</p>\n<pre><code class=\"javascript\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;button @click=&quot;setMessage&quot;&gt;添加属性&lt;/button&gt;\n    &#123;&#123; student.name &#125;&#125;\n    &lt;input type=&quot;text&quot; v-model=&quot;student.age&quot;&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p> 当我们点击按钮，为student添加一个age属性，看看视图层是否能够更新</p>\n<p><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/1.png\" alt=\"在这里插入图片描述\"><br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/2.png\" alt=\"在这里插入图片描述\"><br>在这里我们发现虽然这个对象身上已经有了该属性，但是视图层并没有更新该数据，是什么造成的呢？由于受JavaScript的限制，vue.js不能监听对象属性的添加和删除，因为在vue组件初始化的过程中，会调用getter和setter方法，所以该属性必须是存在在data中，视图层才会响应该数据的变化</p>\n<p>那么，我们该如何解决这个问题呢<br>解决这个问题的方法大体有两种：</p>\n<ol>\n<li>使用this.$set(obj, key, value)&#x2F;vue.set(obj, key, value)</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n data() &#123;\n   return &#123;\n     student: &#123;\n       name: &#39;张三&#39;,\n     &#125;\n   &#125;\n &#125;,\n methods: &#123;\n   setMessage() &#123;\n     this.$set(this.student, &#39;age&#39;, 15)\n     console.log(this.student)\n   &#125;\n &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>通过Object.assign(target, sources)方法</li>\n</ol>\n<pre><code class=\"javascript\">&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      student: &#123;\n        name: &#39;张三&#39;,\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    setMessage() &#123;\n      this.student.age = 15\n      this.student = Object.assign(&#123;&#125;, this.student)\n      console.log(this.student)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p>我们发现，通过这两种方式为对象添加属性之后，他的对象身上多了get和set方法，所以，此时我们再次操作该属性的时候，就会引起视图的更新啦<br><img src=\"/2024/07/25/3-Vue-set%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/3.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"如何判断一个字符串格式是否为JSON字符串","date":"2024-07-25T03:33:56.000Z","description":"如何判断一个字符串格式是否为JSON字符串\n","_content":"\n代码如下：\n````javascript\nfunction isJSON(str) {\n    if (typeof str == 'string') {\n        try {\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == '[object Object]' && obj ){\n                return true;\n            }else{\n                return false;\n            }\n\n        } catch(e) {\n            console.log('error：'+str+'!!!'+e);\n            return false;\n        }\n    }\n    console.log('It is not a string!')\n}\n````","source":"_posts/5-判断一个字符串格式是否为JSON字符串.md","raw":"---\ntitle: 如何判断一个字符串格式是否为JSON字符串\ndate: 2024-07-25 11:33:56\ntags:\n    [js]\ncategories: \n    - web前端\ndescription: |\n    如何判断一个字符串格式是否为JSON字符串\n---\n\n代码如下：\n````javascript\nfunction isJSON(str) {\n    if (typeof str == 'string') {\n        try {\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == '[object Object]' && obj ){\n                return true;\n            }else{\n                return false;\n            }\n\n        } catch(e) {\n            console.log('error：'+str+'!!!'+e);\n            return false;\n        }\n    }\n    console.log('It is not a string!')\n}\n````","slug":"5-判断一个字符串格式是否为JSON字符串","published":1,"updated":"2024-07-25T03:35:21.440Z","comments":1,"layout":"post","photos":[],"_id":"clz0vx9zu0008l8vceyi233pb","content":"<p>代码如下：</p>\n<pre><code class=\"javascript\">function isJSON(str) &#123;\n    if (typeof str == &#39;string&#39;) &#123;\n        try &#123;\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == &#39;[object Object]&#39; &amp;&amp; obj )&#123;\n                return true;\n            &#125;else&#123;\n                return false;\n            &#125;\n\n        &#125; catch(e) &#123;\n            console.log(&#39;error：&#39;+str+&#39;!!!&#39;+e);\n            return false;\n        &#125;\n    &#125;\n    console.log(&#39;It is not a string!&#39;)\n&#125;\n</code></pre>\n","excerpt":"","more":"<p>代码如下：</p>\n<pre><code class=\"javascript\">function isJSON(str) &#123;\n    if (typeof str == &#39;string&#39;) &#123;\n        try &#123;\n            var obj=JSON.parse(str);\n            if(Object.prototype.toString.call(obj) == &#39;[object Object]&#39; &amp;&amp; obj )&#123;\n                return true;\n            &#125;else&#123;\n                return false;\n            &#125;\n\n        &#125; catch(e) &#123;\n            console.log(&#39;error：&#39;+str+&#39;!!!&#39;+e);\n            return false;\n        &#125;\n    &#125;\n    console.log(&#39;It is not a string!&#39;)\n&#125;\n</code></pre>\n"},{"title":"微信小程序 IOS中new Date()时间格式不兼容问题","date":"2024-07-25T03:37:36.000Z","description":"##### 问题描述：\n - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n","_content":"##### 问题描述：\n - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n##### 解决方案：\n - 这里主要兼容问题在于Android可以处理 =='-'== 与 =='/'==  ，而IOS只能处理 =='/'== 的时间格式，具体如下：\n ```javascript\n \t/** 问题描述 */\n    let dateStr1 = '2022-12-12';\n    let dateStr2 = '2022-12-12 00:00';\n    let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n    let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n    /** 解决办法 - 将时间格式转换为 /  */\n    let date3 = new Date(dateStr2.replace(/-/g, '/'));  // 此时 IOS 和 Android 都可以正常显示了\n```\n##### 总结：\n - 这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。\n","source":"_posts/6-微信小程序IOS时间格式不兼容问题.md","raw":"---\ntitle: 微信小程序 IOS中new Date()时间格式不兼容问题\ndate: 2024-07-25 11:37:36\ntags:\n    [js, 微信小程序, IOS]\ncategories: \n    - web前端\ndescription: |\n    ##### 问题描述：\n     - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n---\n##### 问题描述：\n - 最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。\n##### 解决方案：\n - 这里主要兼容问题在于Android可以处理 =='-'== 与 =='/'==  ，而IOS只能处理 =='/'== 的时间格式，具体如下：\n ```javascript\n \t/** 问题描述 */\n    let dateStr1 = '2022-12-12';\n    let dateStr2 = '2022-12-12 00:00';\n    let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n    let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n    /** 解决办法 - 将时间格式转换为 /  */\n    let date3 = new Date(dateStr2.replace(/-/g, '/'));  // 此时 IOS 和 Android 都可以正常显示了\n```\n##### 总结：\n - 这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。\n","slug":"6-微信小程序IOS时间格式不兼容问题","published":1,"updated":"2024-07-25T03:39:48.057Z","comments":1,"layout":"post","photos":[],"_id":"clz0vx9zw000bl8vc6ewm7sxg","content":"<h5 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h5><ul>\n<li>最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。</li>\n</ul>\n<h5 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h5><ul>\n<li>这里主要兼容问题在于Android可以处理 &#x3D;&#x3D;’-‘&#x3D;&#x3D; 与 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D;  ，而IOS只能处理 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D; 的时间格式，具体如下：</li>\n</ul>\n<pre><code class=\"javascript\">    /** 问题描述 */\n   let dateStr1 = &#39;2022-12-12&#39;;\n   let dateStr2 = &#39;2022-12-12 00:00&#39;;\n   let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n   let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n   /** 解决办法 - 将时间格式转换为 /  */\n   let date3 = new Date(dateStr2.replace(/-/g, &#39;/&#39;));  // 此时 IOS 和 Android 都可以正常显示了\n</code></pre>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><ul>\n<li>这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。</li>\n</ul>\n","excerpt":"","more":"<h5 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h5><ul>\n<li>最近在小程序项目中遇到了处理Date时间格式的需求，在Android手机测试是没有发现问题的，但是在IOS上 时间转换出现了错误。</li>\n</ul>\n<h5 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h5><ul>\n<li>这里主要兼容问题在于Android可以处理 &#x3D;&#x3D;’-‘&#x3D;&#x3D; 与 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D;  ，而IOS只能处理 &#x3D;&#x3D;’&#x2F;‘&#x3D;&#x3D; 的时间格式，具体如下：</li>\n</ul>\n<pre><code class=\"javascript\">    /** 问题描述 */\n   let dateStr1 = &#39;2022-12-12&#39;;\n   let dateStr2 = &#39;2022-12-12 00:00&#39;;\n   let date1 = new Date(dateStr1);  // IOS系统自动转换失败得到null，Android 以正常显示\n   let date2 = new Date(dateStr2);  // IOS 和 Android 都可以正常显示\n\n   /** 解决办法 - 将时间格式转换为 /  */\n   let date3 = new Date(dateStr2.replace(/-/g, &#39;/&#39;));  // 此时 IOS 和 Android 都可以正常显示了\n</code></pre>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><ul>\n<li>这里需要注意的是 当日期格式 中不带有 具体时分秒的时候，IOS并不会出现错误。</li>\n</ul>\n"},{"title":"小程序1rpx边框不完美解决方案","date":"2024-07-25T03:41:27.000Z","description":"* 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n","_content":"\n##### 问题描述\n* 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n\n##### 原因\n首先先看看IOS边框缺失的问题\n> 当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失\n\n解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数\n\n然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。\n\n再回过头看导致边框缺失的具体原因是啥。\n\n在这之前需要了解下高分屏的物理像素和虚拟像素的概念\n\n简单来说物理像素是设备的实际像素\n\n虚拟像素是设备的坐标点， 可以简单理解为css像素\n\n而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。\n\n###### 解决办法\n\n我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放\n\n具体的代码如下\n\n```\n\n.border1rpx, .border1rpx_before{\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n}\n.border1rpx::after, .border1rpx_before::before{\n  content: \"\";\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n}\n.border1rpx-full { margin: -1rpx; }\n```\n\n1. 给.border1rpx的元素设置边框宽度为0\n2. 给::after伪元素宽高为两倍，边框设置2rpx，\n3. 边框其他样式继承元素的设置\n4. 然后再缩放0.5来达到边框为1rpx的效果","source":"_posts/7-小程序1rpx边框不完美解决方案.md","raw":"---\ntitle: 小程序1rpx边框不完美解决方案\ndate: 2024-07-25 11:41:27\ntags:\n    [css, 微信小程序]\ncategories: \n    - web前端\ndescription: |\n    * 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n---\n\n##### 问题描述\n* 在小程序开发中，1rpx边框随处可见，如果只是简单的使用`border: 1rpx solid red;`的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。\n\n##### 原因\n首先先看看IOS边框缺失的问题\n> 当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失\n\n解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数\n\n然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。\n\n再回过头看导致边框缺失的具体原因是啥。\n\n在这之前需要了解下高分屏的物理像素和虚拟像素的概念\n\n简单来说物理像素是设备的实际像素\n\n虚拟像素是设备的坐标点， 可以简单理解为css像素\n\n而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。\n\n###### 解决办法\n\n我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放\n\n具体的代码如下\n\n```\n\n.border1rpx, .border1rpx_before{\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n}\n.border1rpx::after, .border1rpx_before::before{\n  content: \"\";\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n}\n.border1rpx-full { margin: -1rpx; }\n```\n\n1. 给.border1rpx的元素设置边框宽度为0\n2. 给::after伪元素宽高为两倍，边框设置2rpx，\n3. 边框其他样式继承元素的设置\n4. 然后再缩放0.5来达到边框为1rpx的效果","slug":"7-小程序1rpx边框不完美解决方案","published":1,"updated":"2024-07-25T03:43:37.929Z","comments":1,"layout":"post","photos":[],"_id":"clz0vx9zw000cl8vc4hn69ibp","content":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>在小程序开发中，1rpx边框随处可见，如果只是简单的使用<code>border: 1rpx solid red;</code>的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。</li>\n</ul>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><p>首先先看看IOS边框缺失的问题</p>\n<blockquote>\n<p>当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失</p>\n</blockquote>\n<p>解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数</p>\n<p>然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。</p>\n<p>再回过头看导致边框缺失的具体原因是啥。</p>\n<p>在这之前需要了解下高分屏的物理像素和虚拟像素的概念</p>\n<p>简单来说物理像素是设备的实际像素</p>\n<p>虚拟像素是设备的坐标点， 可以简单理解为css像素</p>\n<p>而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。</p>\n<h6 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h6><p>我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放</p>\n<p>具体的代码如下</p>\n<pre><code>\n.border1rpx, .border1rpx_before&#123;\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n&#125;\n.border1rpx::after, .border1rpx_before::before&#123;\n  content: &quot;&quot;;\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n&#125;\n.border1rpx-full &#123; margin: -1rpx; &#125;\n</code></pre>\n<ol>\n<li>给.border1rpx的元素设置边框宽度为0</li>\n<li>给::after伪元素宽高为两倍，边框设置2rpx，</li>\n<li>边框其他样式继承元素的设置</li>\n<li>然后再缩放0.5来达到边框为1rpx的效果</li>\n</ol>\n","excerpt":"","more":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>在小程序开发中，1rpx边框随处可见，如果只是简单的使用<code>border: 1rpx solid red;</code>的话，在不同的机型上会有不同的表现， IOS机型可能存在边框缺失，安卓边框较粗。</li>\n</ul>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><p>首先先看看IOS边框缺失的问题</p>\n<blockquote>\n<p>当父元素的高度为奇数时，容易出现上下边框缺失，同理，当父元素宽度为奇数时，容易出现左右边框缺失</p>\n</blockquote>\n<p>解决办法是在边框内部添加一个1rpx的元素或是伪元素，撑开内部使元素的宽高为偶数</p>\n<p>然而我们发现这种方案在Iphone 6等2倍屏可以生效， 但放在如Iphone X等3倍屏下面就很飘了， 还是经常会出现边框缺失的情况， 这种情况下再去把父元素改为2和3共同的倍数就非常不现实了。</p>\n<p>再回过头看导致边框缺失的具体原因是啥。</p>\n<p>在这之前需要了解下高分屏的物理像素和虚拟像素的概念</p>\n<p>简单来说物理像素是设备的实际像素</p>\n<p>虚拟像素是设备的坐标点， 可以简单理解为css像素</p>\n<p>而rpx类似rem，渲染后实际转换成px之后可能存在小数，在不同的设备上多多少少会存在渲染的问题。而1rpx的问题就更加明显，因为不足1个物理像素的话，在IOS会进行四舍五入，而安卓好像统一向上取整，这也是上面两种设备表现不同的原因。</p>\n<h6 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h6><p>我们采用的方法是采用translate:scale(0.5)的方法对边框进行缩放</p>\n<p>具体的代码如下</p>\n<pre><code>\n.border1rpx, .border1rpx_before&#123;\n  position: relative;\n  border-width: 0rpx !important;\n  padding: 0.5rpx;\n  z-index: 0;\n&#125;\n.border1rpx::after, .border1rpx_before::before&#123;\n  content: &quot;&quot;;\n  border-style: inherit;\n  border-color: inherit;\n  border-radius: inherit;\n  box-sizing: border-box !important;\n  position: absolute;\n  border-width: 2rpx !important;\n  left: 0;\n  top: 0;\n  width: 200% !important;\n  height: 200% !important;\n  transform-origin: 0 0;\n  transform: scale(0.5) !important;\n  z-index: -1;\n&#125;\n.border1rpx-full &#123; margin: -1rpx; &#125;\n</code></pre>\n<ol>\n<li>给.border1rpx的元素设置边框宽度为0</li>\n<li>给::after伪元素宽高为两倍，边框设置2rpx，</li>\n<li>边框其他样式继承元素的设置</li>\n<li>然后再缩放0.5来达到边框为1rpx的效果</li>\n</ol>\n"},{"title":"扩大按钮点击范围","date":"2024-07-25T03:50:56.000Z","description":"有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n","_content":"\n##### css增加元素点击范围\n有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n比如页面中有一个按钮\n\n```javascript\n  <text id=\"gl1\" bindtap=\"{{lettering}}\"></text>\n```\ncss代码：\n```javascript\n #gl1{\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n}\n#gl1::before{\n    content:\"\";\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    }\n```\ncss中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧","source":"_posts/9-扩大按钮点击范围.md","raw":"---\ntitle: 扩大按钮点击范围\ndate: 2024-07-25 11:50:56\ntags:\n    [css]\ncategories: \n    - web前端\ndescription: |\n   有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n---\n\n##### css增加元素点击范围\n有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。\n比如页面中有一个按钮\n\n```javascript\n  <text id=\"gl1\" bindtap=\"{{lettering}}\"></text>\n```\ncss代码：\n```javascript\n #gl1{\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n}\n#gl1::before{\n    content:\"\";\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    }\n```\ncss中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧","slug":"9-扩大按钮点击范围","published":1,"updated":"2024-07-25T03:52:29.509Z","comments":1,"layout":"post","photos":[],"_id":"clz0vxa020016l8vc0zuq011u","content":"<h5 id=\"css增加元素点击范围\"><a href=\"#css增加元素点击范围\" class=\"headerlink\" title=\"css增加元素点击范围\"></a>css增加元素点击范围</h5><p>有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。<br>比如页面中有一个按钮</p>\n<pre><code class=\"javascript\">  &lt;text id=&quot;gl1&quot; bindtap=&quot;&#123;&#123;lettering&#125;&#125;&quot;&gt;&lt;/text&gt;\n</code></pre>\n<p>css代码：</p>\n<pre><code class=\"javascript\"> #gl1&#123;\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n&#125;\n#gl1::before&#123;\n    content:&quot;&quot;;\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    &#125;\n</code></pre>\n<p>css中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧</p>\n","excerpt":"","more":"<h5 id=\"css增加元素点击范围\"><a href=\"#css增加元素点击范围\" class=\"headerlink\" title=\"css增加元素点击范围\"></a>css增加元素点击范围</h5><p>有时候页面设计按钮较小，或着由于元素所在区域不适合放置大小，可以采用奇淫技巧（css）增加点击事件的触发范围。<br>比如页面中有一个按钮</p>\n<pre><code class=\"javascript\">  &lt;text id=&quot;gl1&quot; bindtap=&quot;&#123;&#123;lettering&#125;&#125;&quot;&gt;&lt;/text&gt;\n</code></pre>\n<p>css代码：</p>\n<pre><code class=\"javascript\"> #gl1&#123;\n    text-align: center;\n    width: 24rpx;\n    height: 24rpx;\n    position: absolute;\n    top: 50%;\n    left: 22rpx;\n    border-left: 4rpx solid #FFFFFF;\n    border-bottom: 4rpx solid #FFFFFF;\n    -webkit-transform: translate(0,-50%) rotate(-135deg);\n    transform: translate(0,-50%) rotate(45deg);\n&#125;\n#gl1::before&#123;\n    content:&quot;&quot;;\n    position:absolute;\n    top:-20rpx;\n    left:-20rpx;\n    bottom:-20rpx;\n    right:-20rpx;\n    &#125;\n</code></pre>\n<p>css中的伪类可以增加元素事件的触发范围，但却可以做到不影响页面元素的排列，这点是伪类的一个实用小技巧</p>\n"},{"title":"git无法连接远程仓库（GitHub）","date":"2024-07-25T03:44:15.000Z","description":"git报错ssh: connect to host github.com port 22: Connection timed out\n","_content":"\n##### 问题描述\n - 某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时....\n\n![在这里插入图片描述](./1.png)\n通过查阅资料尝试了几种方法之后解决了，在这做个记录。\n\n###### 解决方法\n\n首先需要检查一下SSH是否能够连接成功，输入以下命令\n```\nssh -T git@github.com\n```\n若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法\n\n 1. 打开git bash 命令行窗口，找到密钥生成位置\n \t```\n \tcd ~/.ssh\n \t```\n \t如果找不到，则需要确认是否生成并配置了ssh\n 2. 查看文件是否存在\n\t ```\n\tls\n\t ```\n 3. 若存在则在继续在终端输入以下命令新建一个文件\n \t```\n \tvim config\n \t```\n 4. 接着输入下面内容\n \t```\n \tHost github.com\n\tUser 注册github的邮箱\n\tHostname ssh.github.com\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/id_rsa\n\tPort 443\n \t```\n\t![在这里插入图片描述](./2.png)\n 5. 最后:ZZ退出编辑即可\n\n###### 验证\n\n - `ssh -T git@github.com`\n - 出现提示yes回车即可\n ![在这里插入图片描述](./3.png)\n 验证就能顺利通过了","source":"_posts/8-git无法连接远程仓库（GitHub）.md","raw":"---\ntitle: git无法连接远程仓库（GitHub）\ndate: 2024-07-25 11:44:15\ntags:\n    [git]\ncategories: \n    - 工具\ndescription: |\n   git报错ssh: connect to host github.com port 22: Connection timed out\n---\n\n##### 问题描述\n - 某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时....\n\n![在这里插入图片描述](./1.png)\n通过查阅资料尝试了几种方法之后解决了，在这做个记录。\n\n###### 解决方法\n\n首先需要检查一下SSH是否能够连接成功，输入以下命令\n```\nssh -T git@github.com\n```\n若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法\n\n 1. 打开git bash 命令行窗口，找到密钥生成位置\n \t```\n \tcd ~/.ssh\n \t```\n \t如果找不到，则需要确认是否生成并配置了ssh\n 2. 查看文件是否存在\n\t ```\n\tls\n\t ```\n 3. 若存在则在继续在终端输入以下命令新建一个文件\n \t```\n \tvim config\n \t```\n 4. 接着输入下面内容\n \t```\n \tHost github.com\n\tUser 注册github的邮箱\n\tHostname ssh.github.com\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/id_rsa\n\tPort 443\n \t```\n\t![在这里插入图片描述](./2.png)\n 5. 最后:ZZ退出编辑即可\n\n###### 验证\n\n - `ssh -T git@github.com`\n - 出现提示yes回车即可\n ![在这里插入图片描述](./3.png)\n 验证就能顺利通过了","slug":"8-git无法连接远程仓库（GitHub）","published":1,"updated":"2024-07-25T03:50:05.206Z","comments":1,"layout":"post","photos":[],"_id":"clz0vxa030017l8vc0zaydbx4","content":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时….</li>\n</ul>\n<p><img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/1.png\" alt=\"在这里插入图片描述\"><br>通过查阅资料尝试了几种方法之后解决了，在这做个记录。</p>\n<h6 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h6><p>首先需要检查一下SSH是否能够连接成功，输入以下命令</p>\n<pre><code>ssh -T git@github.com\n</code></pre>\n<p>若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法</p>\n<ol>\n<li>打开git bash 命令行窗口，找到密钥生成位置<pre><code>cd ~/.ssh\n</code></pre>\n 如果找不到，则需要确认是否生成并配置了ssh</li>\n<li>查看文件是否存在<pre><code>ls\n</code></pre>\n</li>\n<li>若存在则在继续在终端输入以下命令新建一个文件<pre><code>vim config\n</code></pre>\n</li>\n<li>接着输入下面内容<pre><code>Host github.com\nUser 注册github的邮箱\nHostname ssh.github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\nPort 443\n</code></pre>\n<img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/2.png\" alt=\"在这里插入图片描述\"></li>\n<li>最后:ZZ退出编辑即可</li>\n</ol>\n<h6 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h6><ul>\n<li><code>ssh -T git@github.com</code></li>\n<li>出现提示yes回车即可<br> <img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/3.png\" alt=\"在这里插入图片描述\"><br> 验证就能顺利通过了</li>\n</ul>\n","excerpt":"","more":"<h5 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h5><ul>\n<li>某一天，开开心心的写完了一篇博客，在向GitHub推送的时候突然报错了，乍一看，报错了，顿时….</li>\n</ul>\n<p><img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/1.png\" alt=\"在这里插入图片描述\"><br>通过查阅资料尝试了几种方法之后解决了，在这做个记录。</p>\n<h6 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h6><p>首先需要检查一下SSH是否能够连接成功，输入以下命令</p>\n<pre><code>ssh -T git@github.com\n</code></pre>\n<p>若还是报这个错ssh: connect to host github.com port 22: Connection timed out就可以使用以下解决办法</p>\n<ol>\n<li>打开git bash 命令行窗口，找到密钥生成位置<pre><code>cd ~/.ssh\n</code></pre>\n 如果找不到，则需要确认是否生成并配置了ssh</li>\n<li>查看文件是否存在<pre><code>ls\n</code></pre>\n</li>\n<li>若存在则在继续在终端输入以下命令新建一个文件<pre><code>vim config\n</code></pre>\n</li>\n<li>接着输入下面内容<pre><code>Host github.com\nUser 注册github的邮箱\nHostname ssh.github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\nPort 443\n</code></pre>\n<img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/2.png\" alt=\"在这里插入图片描述\"></li>\n<li>最后:ZZ退出编辑即可</li>\n</ol>\n<h6 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h6><ul>\n<li><code>ssh -T git@github.com</code></li>\n<li>出现提示yes回车即可<br> <img src=\"/2024/07/25/8-git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88GitHub%EF%BC%89/3.png\" alt=\"在这里插入图片描述\"><br> 验证就能顺利通过了</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/3-Vue-set的正确使用/1.png","post":"clz0vx9zt0007l8vc4n0289ok","slug":"1.png","modified":1,"renderable":0},{"_id":"source/_posts/3-Vue-set的正确使用/2.png","post":"clz0vx9zt0007l8vc4n0289ok","slug":"2.png","modified":1,"renderable":0},{"_id":"source/_posts/3-Vue-set的正确使用/3.png","post":"clz0vx9zt0007l8vc4n0289ok","slug":"3.png","modified":1,"renderable":0},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/1.png","post":"clz0vxa030017l8vc0zaydbx4","slug":"1.png","modified":1,"renderable":0},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/2.png","post":"clz0vxa030017l8vc0zaydbx4","slug":"2.png","modified":1,"renderable":0},{"_id":"source/_posts/8-git无法连接远程仓库（GitHub）/3.png","post":"clz0vxa030017l8vc0zaydbx4","slug":"3.png","modified":1,"renderable":0}],"PostCategory":[{"post_id":"clz0vx9zt0007l8vc4n0289ok","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vx9zx000dl8vcbdqr0zb8"},{"post_id":"clz0vx9zo0001l8vcfpj3guvc","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vx9zx000gl8vc5to6e6jb"},{"post_id":"clz0vx9zu0008l8vceyi233pb","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vx9zy000il8vc0ut1e3tp"},{"post_id":"clz0vx9zw000bl8vc6ewm7sxg","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vx9zy000ll8vc6kkwcv6y"},{"post_id":"clz0vx9zq0003l8vc85f37u58","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vx9zy000nl8vc8hx4czqe"},{"post_id":"clz0vx9zw000cl8vc4hn69ibp","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vx9zz000pl8vc4cs4col3"},{"post_id":"clz0vx9zt0006l8vc5dj240d6","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vx9zz000ql8vc8g13fanx"},{"post_id":"clz0vxa020016l8vc0zuq011u","category_id":"clz0vx9zr0004l8vc0vvv70cr","_id":"clz0vxa04001bl8vc9hde32cl"},{"post_id":"clz0vxa030017l8vc0zaydbx4","category_id":"clz0vxa040019l8vc63ahdybk","_id":"clz0vxa04001dl8vcemmtfllu"}],"PostTag":[{"post_id":"clz0vx9zo0001l8vcfpj3guvc","tag_id":"clz0vx9zs0005l8vcgvwj5e7z","_id":"clz0vx9zy000hl8vc9p6g3y3z"},{"post_id":"clz0vx9zo0001l8vcfpj3guvc","tag_id":"clz0vx9zu000al8vc84nvdx7l","_id":"clz0vx9zy000jl8vc13p063y0"},{"post_id":"clz0vx9zq0003l8vc85f37u58","tag_id":"clz0vx9zx000fl8vcgoa99dnw","_id":"clz0vx9zy000ml8vc9bsm9w0o"},{"post_id":"clz0vx9zt0006l8vc5dj240d6","tag_id":"clz0vx9zx000fl8vcgoa99dnw","_id":"clz0vx9zz000sl8vc8eeqawdz"},{"post_id":"clz0vx9zt0006l8vc5dj240d6","tag_id":"clz0vx9zz000ol8vc1va33ssl","_id":"clz0vx9zz000tl8vc13kk486f"},{"post_id":"clz0vx9zt0007l8vc4n0289ok","tag_id":"clz0vx9zx000fl8vcgoa99dnw","_id":"clz0vxa00000vl8vc2hz8c1iv"},{"post_id":"clz0vx9zu0008l8vceyi233pb","tag_id":"clz0vx9zu000al8vc84nvdx7l","_id":"clz0vxa00000xl8vc8jun4l4i"},{"post_id":"clz0vx9zw000bl8vc6ewm7sxg","tag_id":"clz0vx9zu000al8vc84nvdx7l","_id":"clz0vxa010010l8vc2les4ab3"},{"post_id":"clz0vx9zw000bl8vc6ewm7sxg","tag_id":"clz0vxa00000wl8vcdyxu7tps","_id":"clz0vxa010011l8vc8o8s04ku"},{"post_id":"clz0vx9zw000bl8vc6ewm7sxg","tag_id":"clz0vxa00000yl8vcdu6pcuvk","_id":"clz0vxa010013l8vc72sd14yx"},{"post_id":"clz0vx9zw000cl8vc4hn69ibp","tag_id":"clz0vxa00000zl8vc5fr2ghck","_id":"clz0vxa010014l8vc05bb1ikr"},{"post_id":"clz0vx9zw000cl8vc4hn69ibp","tag_id":"clz0vxa00000wl8vcdyxu7tps","_id":"clz0vxa010015l8vcfx4j05ko"},{"post_id":"clz0vxa020016l8vc0zuq011u","tag_id":"clz0vxa00000zl8vc5fr2ghck","_id":"clz0vxa030018l8vccxdn0aq2"},{"post_id":"clz0vxa030017l8vc0zaydbx4","tag_id":"clz0vxa04001al8vc8sou52d5","_id":"clz0vxa04001cl8vcdo7c81pf"}],"Tag":[{"name":"es6","_id":"clz0vx9zs0005l8vcgvwj5e7z"},{"name":"js","_id":"clz0vx9zu000al8vc84nvdx7l"},{"name":"vue","_id":"clz0vx9zx000fl8vcgoa99dnw"},{"name":"element-ui","_id":"clz0vx9zz000ol8vc1va33ssl"},{"name":"微信小程序","_id":"clz0vxa00000wl8vcdyxu7tps"},{"name":"IOS","_id":"clz0vxa00000yl8vcdu6pcuvk"},{"name":"css","_id":"clz0vxa00000zl8vc5fr2ghck"},{"name":"git","_id":"clz0vxa04001al8vc8sou52d5"}]}}